---
title: "Clean Mapping Data"
output: html_notebook
---



```{r setup, message=FALSE, warning=FALSE}
library(terra)
library(sf)
library(dplyr)
library(ggplot2)
library(glue)
library(tidyr)
library(purrr)
library(diffeR)
library(here)
library(stringr)
library(tidytext)
library(rlang)
library(tidyr)
# source the helper functions
source(here("R", "utils_lcc_metrics.R"))
source(here("R","utils_pct_change.R"))
```


#  1 Organize output Dataframes (make sure that they are complete and correclty named)

Right now, 24/04/2025 the problem is on the way the dataframe with the class colors and names is built. The process is still too manual (writing the table) and is easy to get it wrong when it should not be big deal. 
Also, the order of the factors needs to be set, and new classes have to be added. Again, i don't how to do it easily. I mean, it is easy, but annoying to do and easy to get wrong.


#######################################################
Here, i need to clean the directory form a loto of old versions. Only the groupings. If pct not there, it is fine, that is easy to calculate now. 
```{r load polygons, eval=FALSE, message=FALSE, warning=FALSE, include=FALSE}
# # Read spatial polygon dataset
# 
# inpath <- '/Users/sputnik/Library/CloudStorage/OneDrive-WorldWildlifeFund,Inc/global_NCP/vector'
# inpath <- here("vector")
# sets <- file.path(inpath, list.files(inpath, pattern= 'gpkg$'))
# 
# #cols <- c("id", "continent", "income_grp", "region_wb", "WWF_biome", "HYBAS_ID", "HYBAS_ID")
# #sets <- cbind(sets, cols)
# # Set an index to select the desired dataset
# t <- 10
# # Select the target dataset from the list 
# set <- sets[t]
# # # load polygons
# lyr <- st_layers(set)
# poly <- st_read(set)
# 
# #get the name of the column with the unique ids of the input vector
# col <- colnames(poly[1])[1]
 
```

# Load and pivot 

Here, the spatial objects with the additional attributes are loaded and reformatted for analysis and chart preparation - **pivot & tidy**. 
Add to the documentation , environment or however that's called the vectors to select and order the columns. 
This should actually be done as a database structure. The columns live somehere and are summoned upon need from a set of options (list_dir). 
  EVERYTHING IS DASTABASE MANAGEMENT #####. ###### THAT'S WHAT I AHVE BEEN DOING ALL THESE YEARS!!!!! 
  
  And all of this without knowing SQL !!!!!!!!!

```{r chunk1, eval=FALSE, include=FALSE}
# 
#  get pct as standalone data to add to the table
# Most recent version of synthesis data:
 
poly <- st_read('/Users/rodriguez/Library/CloudStorage/OneDrive-WorldWildlifeFund,Inc/global_ES_TimeSeries/vector/hydrosheds_lv6_synth.gpkg')
# 
 plt <- st_drop_geometry(poly)
 plt <- plt %>%
  dplyr::select(
    1:15, # This is hardcoded for the basins, but has to be adjusted for specific cases/desired columns.
    22,
    contains("pct_ch")
  )
 
 # Edit/Adjust column names 
 names(plt) <- stringr::str_replace_all(names(plt), "_2020_1992", "")
 
 
 ############# PIVOT TABLE ##############################
 plt <- plt %>%
  pivot_longer(
    cols = matches("pct_ch"),  # matches anything containing pct_ch
    names_to = "service",
    names_transform = list(service = as.character),
    values_to = "pct_ch"
  ) %>%
  mutate(service = str_replace(service, "_pct_ch.*", "")) %>%
  as_tibble()
#
 # Adjust Dataframe and labels (yes again. The "_pct_ch" part was necessary until now)
 plt <- plt %>%
   mutate(service = str_remove(service, "_pct_ch"))#
# #This is annoying and should be improved. Made easier. Here i am asjusting/homologuing variable names to a same standard. Because some of the data has been extracted at different moments there is some, ahem, *inconsistency* in the "service" naming structure that I fixed here. 
 plt <- plt %>% mutate(service = case_when(
   service == "n_export" ~ "N_export",
   service == "sed_export" ~ "Sed_export",
   service == "Sed_retention_ratio" ~ "Sed_Ret_R",
   service == "N_export_sqkm" ~ "N_Export_2",
   TRUE ~ service
   ))
# 
#Drop Usle and N_export old 
plt <- plt %>% filter(service!="Usle") %>% filter(service!="N_export") # I am keeping the data in the attribute table because it *might* be necessary at some point, but removing from the reformated table. 
# cd <- as_tibble(cbind(service,color)) # I don't know why this is here. 
#Remove invalid / Inf records
plt <- plt%>% filter(!is.na(pct_ch)) %>% filter(pct_ch != Inf)  
#. Have a method to name versions or something (maybe?)
write.csv(plt, file= here('output_data', "metrics_change_hb_lev_6_2.csv"))

#Drop Usle and N_export old 
plt <- plt %>% filter(service!="Usle") %>% filter(service!="N_export")
```

# Prepare Filter Database

 This could be a dialogue box!!!
```{r load-plt}
# plt <- as_tibble(read.csv(here('output_data', "metrics_change_hb_lev_6.csv")))
# plt[1] <- NULL 
# head(plt)
# # apply filter (5
# apply filter (5% or 2%) # Remove the smallest basins. 
area_threshold <- quantile(plt$SUB_AREA, probs = 0.05, na.rm = TRUE)
# Filter the dataset
df <- plt %>% filter(SUB_AREA > area_threshold)
plt <- plt %>%
  mutate(
    service = factor(service, levels = service_levels),
    pct_ch_trans = pseudo_log(pct_ch)
  )
# get the filtered lcoations

df_filt <- df %>%
  filter(id %in% top_bottom_10k$id)
```

Here, another dialogue to input the variable names, plot colors and set the factor order.
```{r, fig.height=8, fig.width=14  }
service <- unique(plt$service)
service <- c("Coastal_Protection","Pollination","N_Export_2", "Sed_export", "Sed_Ret_R", "N_Ret_Ratio", "Pop_sqkm","GDP" )
 color <- c("#9e9ac8", "#dd1c77","#2c944c", "#08306b", "#17c0ff",  "#8C510A", "#8C510A","#08306b", "#17c0ff")
 service_levels <- service
 cd <- as_tibble(cbind(service,color))
```

```{r fig.height=8, fig.width=14, warning=FALSE}
# 1. Define desired facet order
df <- plt %>% filter(SUB_AREA > area_threshold)
df <- df %>%
  filter(id %in% top_bottom_10k$id)
# 2. Apply pseudo-log transformation
pseudo_log <- function(x) sign(x) * log1p(abs(x))

df <- df %>%
  mutate(
    service = factor(service, levels = service_levels),
    pct_ch_trans = pseudo_log(pct_ch)
  )

# 3. Reorder countries based on dir_ch_2 (descending)
df <- df %>%
  mutate(ee_r264_name = reorder(ee_r264_name, -dir_ch_2))

# 4. Create plot
p <- ggplot(df, aes(x = ee_r264_name, y = pct_ch_trans, fill = ee_r264_name)) +
  geom_violin(trim = FALSE, scale = "width") +
  facet_wrap(~ service, scales = "free_y") +
  scale_fill_viridis_d(option = "D") +
  labs(
    title = "Pseudo-log Scaled % Change by Service ",
    x = NULL,
    y = "Transformed % Change"
  ) +
  theme_minimal() +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1, size = 8),
    strip.text = element_text(face = "bold"),
    legend.position = "none"
  )
# 4. Create plot
p2 <- ggplot(df, aes(x = ee_r264_name, y = pct_ch, fill = ee_r264_name)) +
  geom_violin(trim = FALSE, scale = "width") +
  facet_wrap(~ service, scales = "free_y") +
  scale_fill_viridis_d(option = "D") +
  labs(
    title = "Pseudo-log Scaled % Change by Service ",
    x = NULL,
    y = "Transformed % Change"
  ) +
  theme_minimal() +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1, size = 8),
    strip.text = element_text(face = "bold"),
    legend.position = "none"
  )
p
p2

```

## 5. Here, add plots with the differences 

```{r diffs, fig.height=8, fig.width=14}
col <- "ee_r264_name"
print(col)
print(names(df))
stopifnot(col %in% names(df))

plot_es_changes <- function(data, label_col,
                            filter_type = "top_bottom", filter_val = 10) {
  label_sym <- sym(label_col)

  # Step 2: Apply filtering based on the chosen type
  if (filter_type == "top_bottom") {
    # Top/bottom n observations per service
    top_bottom <- data %>%
      group_by(service) %>%
      slice_max(pct_ch, n = filter_val, with_ties = FALSE) %>%
      bind_rows(
        data %>%
          group_by(service) %>%
          slice_min(pct_ch, n = filter_val, with_ties = FALSE)
      ) %>%
      ungroup()

  } else if (filter_type == "quantile") {
    # Top/bottom quantile per service (e.g., top/bottom 10%)
    top_bottom <- data %>%
      group_by(service) %>%
      filter(pct_ch >= quantile(pct_ch, 1 - filter_val, na.rm = TRUE) |
             pct_ch <= quantile(pct_ch, filter_val, na.rm = TRUE)) %>%
      ungroup()

  } else if (filter_type == "all") {
    top_bottom <- data
  } else {
    stop("Invalid `filter_type`. Use 'top_bottom', 'quantile', or 'all'.")
  }

  # Step 3: Reorder labels per service
  top_bottom <- top_bottom %>%
    mutate(temp_label = reorder_within(!!label_sym, -pct_ch, service))

  # Step 4: Plot
  ggplot(top_bottom, aes(x = temp_label, y = pct_ch, fill = color)) +
    geom_bar(stat = "identity", show.legend = FALSE) +
    scale_fill_identity() +
    scale_x_reordered() +
    facet_wrap(~ service, scales = "free", ncol = 3) +
    labs(
      #title = paste("% Change 1992–2020 By", cols, sep= " "),
      x = NULL,
      y = "% Change"
    ) +
    theme_bw() +
    theme(
      strip.text = element_text(face = "bold", size = 10),
      axis.text.x = element_text(angle = 45, hjust = 1, size = 8)
    )
}

# Top/bottom 10 countries per service
plot_es_changes(df, label_col = col, filter_type = "top_bottom", filter_val = 10)

# Top/bottom 5% per service
plot_es_changes(df, label_col = col, filter_type = "quantile", filter_val = 0.1)

# Show all values
#plot_es_changes(plt, filter_type = "all")
```


## Scatterplots

```{r sctp}


# List of LC metrics to analyze
lc_metrics <- c("Gain_2", "Persistence_2", "Loss_2", "dir_ch_2")

# Loop over each LC metric and generate a faceted scatterplot
for (metric in lc_metrics) {
  p <- df %>%
    ggplot(aes_string(x = metric, y = "pct_ch_trans", color = "color")) +
    geom_point(alpha = 0.5, size = 1.2) +
    facet_wrap(~ service, scales = "free") +
    scale_color_identity() +
    labs(
      title = paste("Relationship Between", metric, "and ES % Change"),
      x = metric,
      y = "% Change in Ecosystem Service"
    ) +
    theme_minimal() +
    theme(
      strip.text = element_text(face = "bold"),
      plot.title = element_text(hjust = 0.5),
      axis.text = element_text(size = 9)
    )

  print(p)
}
```


```{r sctp}

df <- plt %>% filter(SUB_AREA > area_threshold)
# List of LC metrics to analyze
lc_metrics <- c("Gain_2", "Persistence_2", "Loss_2", "dir_ch_2")
pseudo_log <- function(x) sign(x) * log1p(abs(x))

df <- df %>%
  mutate(
    service = factor(service, levels = service_levels),
    pct_ch_trans = pseudo_log(pct_ch)
  )
# Loop over each LC metric and generate a faceted scatterplot
for (metric in lc_metrics) {
  p <- df %>%
    ggplot(aes_string(x = metric, y = "pct_ch_trans", color = "color")) +
    geom_point(alpha = 0.5, size = 1.2) +
    facet_wrap(~ service, scales = "free") +
    scale_color_identity() +
    labs(
      title = paste("Relationship Between", metric, "and ES % Change"),
      x = metric,
      y = "% Change in Ecosystem Service"
    ) +
    theme_minimal() +
    theme(
      strip.text = element_text(face = "bold"),
      plot.title = element_text(hjust = 0.5),
      axis.text = element_text(size = 9)
    )

  print(p)
}
```
# get the filtered lcoations


# Scatterplots change 2

```{r unnamedchunk, fig.height=10, fig.width=14}

# LC metrics of interest
lc_metrics <- c("Gain_2", "Persistence_2", "Loss_2", "dir_ch_2")

# Step 1: Remove top 2% outliers for each service
filtered_plt <- plt %>%
  group_by(service) %>%
  mutate(threshold = quantile(pct_ch, 0.98, na.rm = TRUE)) %>%
  ungroup() %>%
  filter(pct_ch <= threshold)

# Step 2: Apply pseudo-log transformation
filtered_plt <- filtered_plt %>%
  mutate(pct_ch_log = sign(pct_ch) * log1p(abs(pct_ch)))

# Step 3: Loop through each LC metric and create faceted plots
for (metric in lc_metrics) {
  p <- ggplot(filtered_plt, aes_string(x = metric, y = "pct_ch_log", color = "color")) +
    geom_point(alpha = 0.5, size = 1.2) +
    facet_wrap(~ service, scales = "free") +
    scale_color_identity() +
    labs(
      title = paste("% Change vs", metric),
      x = metric,
      y = "Log(% Change in ES)"
    ) +
    theme_minimal() +
    theme(
      strip.text = element_text(face = "bold"),
      plot.title = element_text(hjust = 0.5),
      axis.text = element_text(size = 9)
    )

  print(p)
}
```

```{r eval=FALSE, fig.height=8, fig.width=14, include=FALSE}


# LC metrics of interest
lc_metrics <- c("Gain_2", "Persistence_2", "Loss_2", "dir_ch_2")

# Step 1: Remove top 2% outliers for each service
filtered_plt <- plt %>%
  group_by(service) %>%
  mutate(threshold = quantile(pct_ch, 0.98, na.rm = TRUE)) %>%
  ungroup() %>%
  filter(pct_ch <= threshold)


# Step 3: Loop through each LC metric and create faceted plots
for (metric in lc_metrics) {
  p <- ggplot(filtered_plt, aes_string(x = metric, y = "pct_ch", color = "color")) +
    geom_point(alpha = 0.5, size = 1.2) +
    facet_wrap(~ service, scales = "free") +
    scale_color_identity() +
    labs(
      title = paste(" % Change vs", metric),
      x = metric,
      y = "Log(% Change in ES)"
    ) +
    theme_minimal() +
    theme(
      strip.text = element_text(face = "bold"),
      plot.title = element_text(hjust = 0.5),
      axis.text = element_text(size = 9)
    )

  print(p)
}
```
```{r eval=FALSE, fig.height=8, fig.width=14, include=FALSE}

# apply filter (5 or 2%) # Remove the smalles basins. That help. Also, it seems that some biomes are more prone to artifacts than others!!!
area_threshold <- quantile(plt$SUB_AREA, probs = 0.05, na.rm = TRUE)
# Filter the dataset
df <- plt %>% filter(SUB_AREA > area_threshold)


t_5 <- ggplot(df, aes(x = service, y = pct_ch, fill = color)) +
  geom_boxplot() +  # or geom_violin()
  scale_fill_identity() +
  facet_wrap(~ service, scales = "free_y") +
  labs(
    title = "Distribution of % Change by Service (Excl. Smallest 5% of Basins)",
    x = NULL,
    y = "Percentage Change"
  ) +
  theme_minimal() +
  theme(
    axis.text.x = element_blank(),
    strip.text = element_text(face = "bold"),
    legend.position = "none"
  )

library(ggplot2)
library(dplyr)

# Custom pseudo-log transformation
pseudo_log <- function(x) sign(x) * log1p(abs(x))

# Apply  the filtered dataframe
df <- plt %>%
  mutate(pct_ch_trans = pseudo_log(pct_ch))

# Plot with transformed values
p <- ggplot(df, aes(x = service, y = pct_ch_trans, fill = color)) +
  geom_violin(trim = FALSE, scale = "width") +
  scale_fill_identity() +
  facet_wrap(~ service, scales = "free_y") +
  labs(
    title = "Pseudo-log Scaled % Change by Service",
    x = NULL,
    y = "Transformed % Change"
  ) +
  theme_minimal() +
  theme(
    axis.text.x = element_blank(),
    strip.text = element_text(face = "bold"),
    legend.position = "none"
  )
p
```
## 5. Here, add plots with the differences 

```{r eval=FALSE, fig.height=8, fig.width=14, include=FALSE}
print(col)
print(names(df))
stopifnot(col %in% names(df))

plot_es_changes <- function(data, label_col,
                            filter_type = "top_bottom", filter_val = 10) {
  label_sym <- sym(label_col)

  # Step 2: Apply filtering based on the chosen type
  if (filter_type == "top_bottom") {
    # Top/bottom n observations per service
    top_bottom <- data %>%
      group_by(service) %>%
      slice_max(pct_ch, n = filter_val, with_ties = FALSE) %>%
      bind_rows(
        data %>%
          group_by(service) %>%
          slice_min(pct_ch, n = filter_val, with_ties = FALSE)
      ) %>%
      ungroup()

  } else if (filter_type == "quantile") {
    # Top/bottom quantile per service (e.g., top/bottom 10%)
    top_bottom <- data %>%
      group_by(service) %>%
      filter(pct_ch >= quantile(pct_ch, 1 - filter_val, na.rm = TRUE) |
             pct_ch <= quantile(pct_ch, filter_val, na.rm = TRUE)) %>%
      ungroup()

  } else if (filter_type == "all") {
    top_bottom <- data
  } else {
    stop("Invalid `filter_type`. Use 'top_bottom', 'quantile', or 'all'.")
  }

  # Step 3: Reorder labels per service
  top_bottom <- top_bottom %>%
    mutate(temp_label = reorder_within(!!label_sym, -pct_ch, service))

  # Step 4: Plot
  ggplot(top_bottom, aes(x = temp_label, y = pct_ch, fill = color)) +
    geom_bar(stat = "identity", show.legend = FALSE) +
    scale_fill_identity() +
    scale_x_reordered() +
    facet_wrap(~ service, scales = "free", ncol = 3) +
    labs(
      #title = paste("% Change 1992–2020 By", cols, sep= " "),
      x = NULL,
      y = "% Change"
    ) +
    theme_bw() +
    theme(
      strip.text = element_text(face = "bold", size = 10),
      axis.text.x = element_text(angle = 45, hjust = 1, size = 8)
    )
}

# Top/bottom 10 countries per service
plot_es_changes(df, label_col = col, filter_type = "top_bottom", filter_val = 10)

# Top/bottom 5% per service
#plot_es_changes(df, label_col = col, filter_type = "quantile", filter_val = 0.1)

# Show all values
#plot_es_changes(plt, filter_type = "all")
```


## Scatterplots

```{r}


# List of LC metrics to analyze
lc_metrics <- c("Gain_2", "Persistence_2", "Loss_2", "dir_ch_2")

# Loop over each LC metric and generate a faceted scatterplot
for (metric in lc_metrics) {
  p <- plt %>%
    ggplot(aes_string(x = metric, y = "pct_ch", color = "color")) +
    geom_point(alpha = 0.5, size = 1.2) +
    facet_wrap(~ service, scales = "free") +
    scale_color_identity() +
    labs(
      title = paste("Relationship Between", metric, "and ES % Change"),
      x = metric,
      y = "% Change in Ecosystem Service"
    ) +
    theme_minimal() +
    theme(
      strip.text = element_text(face = "bold"),
      plot.title = element_text(hjust = 0.5),
      axis.text = element_text(size = 9)
    )

  print(p)
}
```


# Scatterplots change 2

```{r, fig.height=8, fig.width=14}


# LC metrics of interest
lc_metrics <- c("Gain_2", "Persistence_2", "Loss_2", "dir_ch_2")

# Step 1: Remove top 2% outliers for each service
filtered_plt <- plt %>%
  group_by(service) %>%
  mutate(threshold = quantile(pct_ch, 0.98, na.rm = TRUE)) %>%
  ungroup() %>%
  filter(pct_ch <= threshold)

# # Step 2: Apply pseudo-log transformation
# filtered_plt <- filtered_plt %>%
#   mutate(pct_ch_log = sign(pct_ch) * log1p(abs(pct_ch)))

# Step 3: Loop through each LC metric and create faceted plots
for (metric in lc_metrics) {
  p <- ggplot(filtered_plt, aes_string(x = metric, y = "pct_ch", color = "color")) +
    geom_point(alpha = 0.5, size = 1.2) +
    facet_wrap(~ service, scales = "free") +
    scale_color_identity() +
    labs(
      title = paste("Log-Transformed % Change vs", metric),
      x = metric,
      y = "Log(% Change in ES)"
    ) +
    theme_minimal() +
    theme(
      strip.text = element_text(face = "bold"),
      plot.title = element_text(hjust = 0.5),
      axis.text = element_text(size = 9)
    )

  print(p)
}
```

```{r, fig.height=8, fig.width=14}
# library(dplyr)
# library(ggplot2)
# 
# plt <- as_tibble(read.csv(here('output_data', "metrics_change_hb_lev_6.csv")))
# plt[1] <- NULL 
# # apply filter (5 or 2%) # Remove the smalles basins. That help. Also, it seems that some biomes are more prone to artifacts than others!!!
# area_threshold <- quantile(plt$SUB_AREA, probs = 0.05, na.rm = TRUE)
# # Filter the dataset
# df <- plt %>% filter(SUB_AREA > area_threshold)
# 
# 
# t_5 <- ggplot(df, aes(x = service, y = pct_ch, fill = color)) +
#   geom_boxplot() +  # or geom_violin()
#   scale_fill_identity() +
#   facet_wrap(~ service, scales = "free_y") +
#   labs(
#     title = "Distribution of % Change by Service (Excl. Smallest 5% of Basins)",
#     x = NULL,
#     y = "Percentage Change"
#   ) +
#   theme_minimal() +
#   theme(
#     axis.text.x = element_blank(),
#     strip.text = element_text(face = "bold"),
#     legend.position = "none"
#   )
# 
# library(ggplot2)
# library(dplyr)
# 
# # Custom pseudo-log transformation
# pseudo_log <- function(x) sign(x) * log1p(abs(x))
# 
# # Apply to the filtered dataframe
# df <- plt %>% 
#   mutate(pct_ch_trans = pseudo_log(pct_ch))
# 
# # Plot with transformed values
# p <- ggplot(df, aes(x = service, y = pct_ch_trans, fill = color)) +
#   geom_violin(trim = FALSE, scale = "width") +
#   scale_fill_identity() +
#   facet_wrap(~ service, scales = "free_y") +
#   labs(
#     title = "Pseudo-log Scaled % Change by Service",
#     x = NULL,
#     y = "Transformed % Change"
#   ) +
#   theme_minimal() +
#   theme(
#     axis.text.x = element_blank(),
#     strip.text = element_text(face = "bold"),
#     legend.position = "none"
#   )
# p
```





