---
title: "KS tests: hotspots vs non-hotspots"
subtitle: "v{{< meta analysis_version >}}"
author: "Jerónimo Rodríguez Escobar"
analysis_version: "v0.5.0"
format:
  html:
    toc: true
    number-sections: true
    code-fold: false
    toc-title: "Contents"
    theme: cosmo
  pdf:
    toc: true
    number-sections: true
    geometry: margin=1in
    df-print: kable
editor: source
execute:
  freeze: auto
---

## Setup

Uses the same wiring as the hotspot extraction report: load project helpers, set a stable root, and keep output paths under `outputs/`.

```{r}
#| label: setup
#| message: false
#| warning: false
#| echo: false

library(dplyr)
library(tidyr)
library(purrr)
library(stringr)
library(forcats)
library(ggplot2)
library(readr)
library(scales)
library(sf)
library(here)

library(devtools)   # load package helpers in /R

knitr::opts_knit$set(root.dir = here::here())
source(here::here("R","paths.R"))
devtools::load_all(quiet = TRUE)

options(dplyr.summarise.inform = FALSE)
Sys.setenv(GDAL_NUM_THREADS = "ALL_CPUS", PROJ_NETWORK = "ON")
set.seed(1)
```

## Config

Central switches to adjust  thresholds, services, variables, sampling, and output locations. This mirrors the hotspot extraction config (loss/gain/combos) so KS uses the same hotspot definition.

```{r}
#| label: config
#| echo: true

`%||%` <- function(x, y) if (is.null(x)) y else x

KS_CFG <- list(
  # hotspot definition (keep in sync with hotspot_extraction.qmd)
  pct_cutoff     = 0.05,
  threshold_mode = "percent",
  rule_mode      = "vectors",
  loss_services  = c("Nature_Access","Pollination","N_Ret_Ratio","Sed_Ret_Ratio","C_Risk_Red_Ratio"),
  gain_services  = c("Sed_export","N_export","C_Risk"),
  combos = list(
    deg_combo = c("Nature_Access","Pollination","N_export","Sed_export","C_Risk"),
    rec_combo = c("Nature_Access","Pollination","N_Ret_Ratio","Sed_Ret_Ratio","C_Risk_Red_Ratio")
  ),
  include_services = c(
    "C_Risk","N_export","Sed_export",
    "C_Risk_Red_Ratio","N_Ret_Ratio","Sed_Ret_Ratio",
    "Pollination","Nature_Access"
  ),
  # KS settings
  vars_to_test = c(
    "rast_gdpTot_1990_2020_30arcsec_2020_sum",
    "GHS_POP_E2020_GLOBE_sum",
    "GlobPOP_Count_30arc_2020_sum",
    "GHS_BUILT_S_E2020_mean",
    "fields_mehrabi_2017_mean",
    "hdi_raster_predictions_2020_mean",
    "rast_adm1_gini_disp_2020_mean"
  ),
  sampling          = "match_hot",  # none | match_hot | cap_nonhot
  nonhot_cap        = 100000L,
  permute_n         = 0,            # set >0 for permutation p
  compute_one_sided = TRUE,
  adjust_method     = "BH",
  # ECDF / plotting switches
  transform_default = "auto",
  transform_by_var = c(
    "rast_gdpTot_1990_2020_30arcsec_2020_sum" = "log1p",
    "GHS_POP_E2020_GLOBE_sum"                 = "log1p",
    "GlobPOP_Count_30arc_2020_sum"            = "log1p"
  ),
  ecdf_top_k              = 8,
  ecdf_service_selection  = "top_k",  # top_k | all | custom
  mountain_service        = "Pollination",
  mountain_var            = "rast_gdpTot_1990_2020_30arcsec_2020_sum",
  mountain_transform      = "log1p",
  # outputs
  out_table  = out_tables("ks_results_hot_vs_non.csv"),
  out_dir    = out_plots("ks"),
  latest_dir = out_plots("latest","ks")
)
```

## Pivot to long (cached)

Build `plt_long` from the processed grid, harmonizing service labels and keeping the socio variables we test. Cached so future renders skip the heavy pivot.

```{r}
#| label: pivot
#| eval: true
#| include: false
#| echo: false
#| results: hide
#| cache: true

if (!exists("plt_long", inherits = TRUE)) {
  gpkg <- file.path(data_dir(), "processed", "10k_change_calc.gpkg")
  stopifnot(file.exists(gpkg))

  sf_f <- sf::st_read(gpkg, quiet = TRUE)
  if (!"fid" %in% names(sf_f)) sf_f$fid <- seq_len(nrow(sf_f))
  plt <- sf::st_drop_geometry(sf_f)

  id_cols  <- c("fid", "c_fid")
  chg_cols <- grep("_(abs|pct)_chg$", names(plt), value = TRUE)
  socio_vars <- setdiff(names(plt), c(id_cols, chg_cols))

  plt_long <- plt |>
    tidyr::pivot_longer(
      cols = tidyselect::all_of(chg_cols),
      names_to = c("service", "chg_type"),
      names_pattern = "^(.*)_(abs|pct)_chg$",
      values_to = "chg_value"
    ) |>
    dplyr::mutate(service = stringr::str_remove(service, "_mean$")) |>
    tidyr::pivot_wider(
      names_from  = chg_type,
      values_from = chg_value,
      names_vary  = "slowest"
    ) |>
    dplyr::rename(abs_chg = abs, pct_chg = pct) |>
    dplyr::select(fid, c_fid, service, abs_chg, pct_chg, dplyr::any_of(socio_vars)) |>
    dplyr::filter(!is.na(c_fid)) |>
    dplyr::filter(!(is.infinite(abs_chg) | is.infinite(pct_chg))) |>
    dplyr::filter(!is.na(abs_chg) | !is.na(pct_chg))

  service_lookup <- c(
    sed_export     = "Sed_export",
    n_export       = "N_export",
    n_retention    = "N_retention",
    nature_access  = "Nature_Access",
    pollination    = "Pollination",
    usle           = "USLE",
    n_ret_ratio    = "N_Ret_Ratio",
    sed_ret_ratio  = "Sed_Ret_Ratio",
    Rt_ratio       = "C_Risk_Red_Ratio",
    Rt             = "C_Risk",
    Rt_service     = "C_Prot_service",
    Rt_nohab       = "Rt_nohab"
  )
  plt_long <- plt_long |>
    dplyr::mutate(service = dplyr::recode(service, !!!service_lookup, .default = service))
}

svc_order <- c(
  "C_Risk","N_export","Sed_export",
  "C_Risk_Red_Ratio","N_Ret_Ratio","Sed_Ret_Ratio",
  "Pollination","Nature_Access"
)
extras <- setdiff(unique(plt_long$service), svc_order)
plt_long <- plt_long |>
  dplyr::mutate(service = factor(service, levels = c(svc_order, sort(extras))))
```

## Derive hotspots (hotspot vs complement)

Apply the hotspot definition to `plt_long` to get `hotspots_df` and `non_hotspots_df`. This uses the same loss/gain vectors and cutoff as the hotspot extraction report.

```{r}
#| label: build-hotspots
#| message: false
#| warning: false

svc_keep <- KS_CFG$include_services %||% levels(plt_long$service) %||% unique(plt_long$service)
hs <- extract_hotspots(
  df            = dplyr::filter(plt_long, service %in% svc_keep),
  value_col     = "pct_chg",
  pct_cutoff    = KS_CFG$pct_cutoff,
  threshold_mode= KS_CFG$threshold_mode,
  rule_mode     = KS_CFG$rule_mode,
  loss_services = KS_CFG$loss_services,
  gain_services = KS_CFG$gain_services,
  combos        = KS_CFG$combos,
  id_cols       = c("c_fid")
)

hotspots_df <- hs$hotspots_df
inverse_df  <- hs$non_hotspots_df

stopifnot(nrow(hotspots_df) > 0, nrow(inverse_df) > 0)
```

## KS tests: hotspots vs non-hotspots

Run KS per `service × variable`, with optional downsampling of the non-hotspot pool. Results are written to `outputs/tables/ks_results_hot_vs_non.csv`.

```{r}
#| label: run-ks
#| message: false
#| warning: false

dir.create(dirname(KS_CFG$out_table), recursive = TRUE, showWarnings = FALSE)
ks_res <- run_ks_hot_vs_non(
  hotspots_df      = hotspots_df,
  inverse_df       = inverse_df,
  vars             = KS_CFG$vars_to_test,
  include_services = svc_keep,
  sampling         = KS_CFG$sampling,
  nonhot_cap       = KS_CFG$nonhot_cap,
  permute_n        = KS_CFG$permute_n,
  compute_one_sided= KS_CFG$compute_one_sided,
  adjust_method    = KS_CFG$adjust_method,
  out_csv          = KS_CFG$out_table
)

dplyr::glimpse(ks_res, width = 120)
```

## Visualizations and exports

Heatmap, per-variable bars, ECDF overlays (top-K services per variable), and an optional mountain plot. Plots are saved under `outputs/plots/ks/` and mirrored to `outputs/plots/latest/ks/` for embedding.

```{r}
#| label: ks-plots
#| message: false
#| warning: false
#| echo: false

ks_plot_dir <- KS_CFG$out_dir
dir.create(ks_plot_dir, recursive = TRUE, showWarnings = FALSE)

# Heatmap
heat_path <- file.path(ks_plot_dir, "ks_heatmap.png")
ggplot2::ggsave(
  heat_path,
  plot_ks_heatmap(ks_res, fill_limits = c(0, NA)),
  width = 10, height = 6, dpi = 300, bg = "white"
)

# Bars by variable
bar_files <- character(0)
for (v in KS_CFG$vars_to_test) {
  safe_v <- gsub("[^A-Za-z0-9_]+", "_", v)
  p_bar <- plot_ks_bars(ks_res, v, top_k = 12)
  out <- file.path(ks_plot_dir, paste0("ks_bars_", safe_v, ".png"))
  ggplot2::ggsave(out, p_bar, width = 8, height = 6, dpi = 300, bg = "white")
  bar_files <- c(bar_files, out)
}

# ECDF grids
ecdf_dir <- file.path(ks_plot_dir, "ecdf")
dir.create(ecdf_dir, recursive = TRUE, showWarnings = FALSE)
ecdf_files <- save_ecdf_grids(
  hotspots_df, inverse_df,
  vars                = KS_CFG$vars_to_test,
  ks_res              = ks_res,
  service_selection   = KS_CFG$ecdf_service_selection,
  top_k               = KS_CFG$ecdf_top_k,
  transform_default   = KS_CFG$transform_default,
  transform_by_var    = KS_CFG$transform_by_var,
  out_dir             = ecdf_dir,
  prefix              = "ecdf",
  width = 10, height = 7, dpi = 300, use_ragg = TRUE,
  verbose = FALSE
)

# Optional mountain plot
mountain_file <- NULL
if (!is.null(KS_CFG$mountain_service) && !is.null(KS_CFG$mountain_var)) {
  mountain_file <- file.path(
    ks_plot_dir,
    paste0("mountain_", gsub("[^A-Za-z0-9_]+","_", KS_CFG$mountain_service), "_",
           gsub("[^A-Za-z0-9_]+","_", KS_CFG$mountain_var), ".png")
  )
  p_mtn <- plot_ks_mountain(
    hotspots_df, inverse_df,
    service_id = KS_CFG$mountain_service,
    var_id     = KS_CFG$mountain_var,
    transform  = KS_CFG$mountain_transform
  )
  ggplot2::ggsave(mountain_file, p_mtn, width = 8, height = 5, dpi = 300, bg = "white")
}

# Mirror to outputs/plots/latest/ks for embedding
dir.create(KS_CFG$latest_dir, recursive = TRUE, showWarnings = FALSE)
old_latest <- list.files(KS_CFG$latest_dir, full.names = TRUE, all.files = FALSE)
if (length(old_latest)) invisible(file.remove(old_latest))

all_pngs <- list.files(ks_plot_dir, pattern = "\\.png$", recursive = TRUE, full.names = TRUE)
all_pngs <- all_pngs[!grepl("/latest/", all_pngs)]
if (length(all_pngs)) {
  invisible(file.copy(all_pngs, KS_CFG$latest_dir, overwrite = TRUE))
}
```

## Quick looks

```{r}
#| label: ks-preview
#| echo: false
#| results: 'asis'

ks_latest_abs <- KS_CFG$latest_dir
pngs <- list.files(ks_latest_abs, pattern = "\\.png$", full.names = FALSE)
if (length(pngs)) {
  rel_dir <- file.path("..", "outputs", "plots", "latest", "ks")
  rel_paths <- file.path(rel_dir, sort(pngs))
  md <- paste(sprintf("![](%s)", rel_paths), collapse = "\n\n")
  knitr::asis_output(md)
} else {
  knitr::asis_output("> No KS plots were generated; check upstream chunks.")
}
```
