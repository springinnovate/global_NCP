---
title: "Beneficiary consolidation
output: html_notebook
---
# Zonal Stat Exctraction and exploratory analysis 

```{r setup, message=FALSE, warning=FALSE}
library(terra)
library(sf)
library(dplyr)
library(ggplot2)
library(glue)
library(tidyr)
library(purrr)
library(diffeR)
library(here)
library(stringr)
library(tidytext)
library(rlang)
library(tidyr)
library(forcats)
library(scales)
library(RColorBrewer)
library(htmltools)
library(leaflet)
# source the helper functions
source(here("R", "hotSpotR.R"))
source(here("R","scattR.R"))
source(here("R","utils_pct_change.R"))
source(here("R", "utils_lcc_metrics.R"))
source(here("R","utils_pct_change.R"))
source(here("R", "perc_filteR.R"))

```
 I moved some chunks from here to the end of **Consolidation.Rmd**. They kept distracting me and making me waste even more time each time i had to make sens of this, and the worst , wasting time. I will move wha was here away to avoidgetting confused (again), but kep record where i put in csase i ever need to review this. If at some point that is nto neceesary anymore, i will move that to old_notebook, but for the love of Bochica, keep our working spaces clean !!
THis cleans the data/consolidates columns that are going to be analyzed keep at hands, the rest is sent to a storage. there should be a database structure here. 


Here, another dialogue to input the variable names, plot colors and set the factor order.
Find out why i did this!!!
Load the input ecosystem service data for the final priortized Ecosysye Service Change Data */output_data/metrics_change_hb_lev_6.csv* 
By 19/05/2025 it contains. change values for following ES datalayers synthetzed at the Basin_lv6: 

"Sed_export"         "Sed_Ret_Ratio"      "Coastal_Protection" "Pollination"        "N_export"           "Pop_sqkm"           "GDP"                "N_Ret_Ratio"

```{r, fig.height=8, fig.width=14  }
#Load chnage data in long format/ 
plt <- read.csv(here("output_data", "metrics_change_hb_lev_6.csv"))
# plt[1] <- NULL Update this with the names of the variables being assessed. There should be a less annoying way to do this. Thaty;s why noting works. These names are not for the object i just loaded!!!!
service <- unique(plt$service)
service <- c("GHS_BUILT","GDP","GHS_POP","HDI", "Farm_size", "GlobPOP")
 color <- c("#9e9ac8", "#dd1c77","#2c944c", "#2c711c","#08306b", "#02606b")
 service_levels <- service
 cd <- as_tibble(cbind(service,color))
 #check and join. 
 plt <- left_join(plt, cd)
```


 This could be a dialogue box!!!
```{r remove lowestvalues to reduce artifacts}
# Calculate pseudo_log val for display purposes. 
plt <- plt %>%
  mutate(
    service = factor(service, levels = service_levels),
    pct_ch_trans = pseudo_log(pct_ch)
  )

# apply filter (5% or 2%) # Remove the smallest basins. 
area_threshold <- quantile(plt$SUB_AREA, probs = 0.05, na.rm = TRUE)
# Filter the dataset
df <- plt %>% filter(SUB_AREA > area_threshold)

write.csv(plt, here("output_data", "serv_benef_synth_01.csv"))
# get the filtered locations
```


#####################################

Start HERE!!!!


## Scatterplots
 Ready the data (load and adjust symbols
```{r other plot}
#load the ecosysytem service dsata in long format
plt <- as_tibble(read.csv(here("output_data", "serv_benef_synth_01.csv")))

# get the filtered locations
area_threshold <- quantile(plt$SUB_AREA, probs = 0.05, na.rm = TRUE)
# Filter the dataset. Remove smallest 5% of the basins
df <- plt %>% filter(SUB_AREA > area_threshold)
# Set the levesl. This seems banal; but is important because iut defines how the layer facets will be rendered. Is also annoying because i can't think about a way to do it which is 
# 3 Columns, 2 Rows:
service <- c("Coastal_Protection","N_export","Sed_export","Pollination","N_Ret_Ratio","Sed_Ret_Ratio")
 color <- c("#9e9ac8", "#dd1c77","#2c944c", "#2c711c","#08306b", "#02606b")
 service_levels <- service

df <- df %>%
  mutate(
    service = factor(service, levels = service_levels),
  )



# 3. List of Benef data to analyze. We can profit and set the names here. I am thinking about the best sat to get (sum/mean. Is not as evident as it seems at first) 
lc_metrics <- c("rast_gdpTot_1990_2020_30arcsec.7_mean","GHS_POP_E2020_GLOBE_R2023A_4326_3ss_V1_0.1_mean","GlobPOP_Count_30arc_2020_I32.1_sum","hdi_raster_predictions_2020.1_mean","farmsize_mehrabi.1_mean","GlobPOP_sqkm","dir_ch_2")
names <- c("Mean GDP 2020", "Mean GHS Population Mean 2020", "GlobPop Sum 2020", "Mean HDI 2020", "Farmsize 2017", "GlobPop/kmˆ2", "LCover Change")
nam <- as_tibble(cbind(lc_metrics,names))
```



```{r scatterplots 2, fig.height=9, fig.width = 12}

# Set PDF output: landscape (width > height), e.g., A4 landscape is ~11.7 x 8.3 inches
pdf(here("output_charts", "scatterplots_by_service.pdf"), width = 11.7, height = 8)


df_f <- df %>%
  group_by(service) %>%
  mutate(threshold = quantile(pct_ch, 0.95, na.rm = TRUE)) %>%
  ungroup() %>%
  filter(pct_ch <= threshold)



plot_es_lc_scatter(df, lc_metrics, nam=nam)


plot_es_lc_scatter(df, lc_metrics = "farmsize_mehrabi.1_mean", nam=nam, geom_type = "point")

plot_es_lc_scatter(df,
                   lc_metrics = "farmsize_mehrabi.1_mean",
                   service_filter = "N_export", nam=nam, geom_type = "point")

```


###########################################################


```{r fig.height=8, fig.width=10, warning=FALSE}
library(dplyr)

# 1. Identify hotspots by service
df_hotspots <- df %>%
  group_by(service) %>%
  mutate(
    upper_threshold = quantile(pct_ch, 0.999, na.rm = TRUE),
    lower_threshold = quantile(pct_ch, 0.001, na.rm = TRUE),
    hotspot_flag = case_when(
      pct_ch >= upper_threshold ~ "high",
      pct_ch <= lower_threshold ~ "low",
      TRUE ~ NA_character_
    ),
    hotspot_binary = !is.na(hotspot_flag)
  ) %>%
  ungroup()

# 2. Count how many times each HYBAS_ID is a hotspot
hotspot_summary <- df_hotspots %>%
  filter(hotspot_binary) %>%
  group_by(HYBAS_ID) %>%
  summarise(
    hotspot_count = n(),
    hotspot_services = list(unique(service))
  )
hotspot_summary <- hotspot_summary %>%
  mutate(hotspot_services = lapply(hotspot_services, \(x) trimws(as.character(x))),
         hotspot_services = sapply(hotspot_services, \(x) paste(x, collapse = ", ")))

spring_ES <- spring_ES %>%
  mutate(HYBAS_ID = as.double(HYBAS_ID))

spring_ES <- left_join(spring_ES, hotspot_summary, by = "HYBAS_ID")

#st_write(spring_ES, here('vector', "hydrosheds_lv_6_hotspots.gpkg"))
```

# Create maps
```{r create_maps}
# Load libraries
library(sf)
library(dplyr)
library(tidyr)
library(leaflet)
library(RColorBrewer)
library(htmltools)

spring_ES <- st_read(here('vector', "hydrosheds_lv_6_hotspots.gpkg"))

# ---------------------------------------------
# Step 1. Define services to include in the map
# ---------------------------------------------
services <- c(
  "sed_export_pct_ch", "Usle_pct_ch", "Sed_retention_ratio_pct_ch",
  "Coastal_Protection_pct_ch", "Pollination_pct_ch", "N_export_pct_ch_2020_1992_sqkm"
)

# ---------------------------------------------
# Step 2. Prepare data: pivot and clean
# ---------------------------------------------
spring_hotspots_long <- spring_ES %>%
  select(HYBAS_ID, geom, all_of(services)) %>%
  pivot_longer(
    cols = all_of(services),
    names_to = "service",
    values_to = "value"
  ) %>%
  filter(!is.na(value) & is.finite(value)) %>%
  mutate(
    label = paste("HYBAS:", HYBAS_ID,
                  "<br>Service:", service,
                  "<br>Change:", round(value, 2))
  ) %>%
  st_as_sf() %>%
  st_make_valid() %>%
  st_transform(4326)

# ---------------------------------------------
# Step 3. Define color palette (diverging red-blue)
# ---------------------------------------------
pal <- colorNumeric(
  palette = "RdBu",
  domain = spring_hotspots_long$value,
  reverse = TRUE
)

# ---------------------------------------------
# Step 4. Initialize leaflet map with base layers
# ---------------------------------------------
m <- leaflet(options = leafletOptions(preferCanvas = TRUE)) %>%
  addProviderTiles("OpenStreetMap.Mapnik", group = "OSM") %>%
  addProviderTiles("CartoDB.Positron", group = "Positron") %>%
  addProviderTiles("Esri.WorldImagery", group = "Satellite")

# ---------------------------------------------
# Step 5. Add a service-specific overlay per layer
# ---------------------------------------------
for (svc in unique(spring_hotspots_long$service)) {
  layer_data <- filter(spring_hotspots_long, service == svc)
  m <- m %>% addPolygons(
    data = layer_data,
    fillColor = ~pal(value),
    fillOpacity = 0.7,
    color = "black", weight = 0.3,
    label = ~lapply(label, HTML),
    group = svc
  )
}

# ---------------------------------------------
# Step 6. Add layer control and legend
# ---------------------------------------------
m <- m %>%
  addLayersControl(
    baseGroups = c("OSM", "Positron", "Satellite"),
    overlayGroups = unique(spring_hotspots_long$service),
    options = layersControlOptions(collapsed = FALSE)
  ) %>%
  addLegend(
    "bottomright",
    pal = pal,
    values = spring_hotspots_long$value,
    title = "% Change"
  )

# ---------------------------------------------
# Step 7. Render the map
# ---------------------------------------------
m


```

# light version

```{r light version}

# Load libraries (if not already loaded)
library(sf)
library(dplyr)
library(tidyr)
library(leaflet)
library(RColorBrewer)
library(htmltools)

# ---------------------------------------------
# Step 1. Define services to include in the map
# ---------------------------------------------
services <- c(
  "sed_export_pct_ch", "Usle_pct_ch", "Sed_retention_ratio_pct_ch",
  "Coastal_Protection_pct_ch", "Pollination_pct_ch", "N_export_pct_ch_2020_1992_sqkm"
)

# ---------------------------------------------
# Step 2. Pivot data and filter only one service + sample
# ---------------------------------------------
# Choose service to visualize (change as needed)
target_service <- "Sed_retention_ratio_pct_ch"

spring_hotspots_sample <- spring_ES %>%
  select(HYBAS_ID, geom, all_of(target_service)) %>%
  rename(value = !!target_service) %>%
  filter(!is.na(value) & is.finite(value)) %>%
  slice_sample(n = 5000) %>%
  mutate(
    service = target_service,
    label = paste("HYBAS:", HYBAS_ID,
                  "<br>Service:", service,
                  "<br>Change:", round(value, 2))
  ) %>%
  st_as_sf() %>%
  st_make_valid() %>%
  st_transform(4326)

# ---------------------------------------------
# Step 3. Define color palette (diverging red-blue)
# ---------------------------------------------
pal <- colorNumeric(
  palette = "RdBu",
  domain = spring_hotspots_sample$value,
  reverse = FALSE
)

# ---------------------------------------------
# Step 4. Build fast interactive map
# ---------------------------------------------
m <- leaflet(options = leafletOptions(preferCanvas = TRUE)) %>%
  addProviderTiles("CartoDB.Positron", group = "Positron") %>%
  addPolygons(
    data = spring_hotspots_sample,
    fillColor = ~pal(value),
    fillOpacity = 0.7,
    color = "black", weight = 0.3,
    label = ~lapply(label, HTML),
    group = target_service
  ) %>%
  addLayersControl(
    baseGroups = c("Positron"),
    overlayGroups = c(target_service),
    options = layersControlOptions(collapsed = FALSE)
  ) %>%
  addLegend(
    "bottomright",
    pal = pal,
    values = spring_hotspots_sample$value,
    title = "% Change"
  )

# ---------------------------------------------
# Step 5. Show the map
# ---------------------------------------------
m

```

# 3. Reorder countries based on dir_ch_2 (descending)
```{r }
df <- df %>%
  mutate(ee_r264_name = reorder(ee_r264_name, -dir_ch_2))
# 4. Create plot
p <- ggplot(df, aes(x = ee_r264_name, y = pct_ch_trans, fill = ee_r264_name)) +
  geom_violin(trim = FALSE, scale = "width") +
  facet_wrap(~ service, scales = "free_y") +
  scale_fill_viridis_d(option = "D") +
  labs(
    title = "Pseudo-log Scaled % Change by Service ",
    x = NULL,
    y = "Transformed % Change"
  ) +
  #theme_minimal() +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1, size = 8),
    strip.text = element_text(face = "bold"),
    legend.position = "none"
  )
# 4. Create plot
p2 <- ggplot(df, aes(x = ee_r264_name, y = pct_ch, fill = ee_r264_name)) +
  geom_violin(trim = FALSE, scale = "width") +
  facet_wrap(~ service, scales = "free_y") +
  scale_fill_viridis_d(option = "D") +
  labs(
    title = "% Change by Service ",
    x = NULL,
    y = "Transformed % Change"
  ) +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1, size = 8),
    strip.text = element_text(face = "bold"),
    legend.position = "none"
  )
p
p2

```
######################################################################################
## 5. add plots with the differences 

Convert into function. We don't need this right now!!!
```{r, fig.height=8, fig.width=14}
col <- "HYBAS_ID"
# create thew function. THIS is what i need to get righ (save as a function)
plot_es_changes <- function(data, label_col, #labelr col has the column with the ind IDs.
                            filter_type = "top_bottom", filter_val = 10) {
  label_sym <- sym(label_col)
  # Step 2: Apply filtering based on the chosen type
  if (filter_type == "top_bottom") {
    # Top/bottom n observations per service
    top_bottom <- data %>%
      group_by(service) %>%
      slice_max(pct_ch, n = filter_val, with_ties = FALSE) %>%
      bind_rows(
        data %>%
          group_by(service) %>%
          slice_min(pct_ch, n = filter_val, with_ties = FALSE)
      ) %>%
      ungroup()

  } else if (filter_type == "quantile") {
    # Top/bottom quantile per service (e.g., top/bottom 10%)
    top_bottom <- data %>%
      group_by(service) %>%
      filter(pct_ch >= quantile(pct_ch, 1 - filter_val, na.rm = TRUE) |
             pct_ch <= quantile(pct_ch, filter_val, na.rm = TRUE)) %>%
      ungroup()

  } else if (filter_type == "all") {
    top_bottom <- data
  } else {
    stop("Invalid `filter_type`. Use 'top_bottom', 'quantile', or 'all'.")
  }

  # Step 3: Reorder labels per service ## This is stupid. Better to order the labels outside
  top_bottom <- top_bottom %>%
    mutate(temp_label = reorder_within(!!label_sym, -pct_ch, service))

  # Step 4: Plot
  ggplot(top_bottom, aes(x = temp_label, y = pct_ch)) +#, fill = color)) +
    geom_bar(stat = "identity", show.legend = FALSE) +
    scale_fill_identity() +
    scale_x_reordered() +
    facet_wrap(~ service, scales = "free", ncol = 3) +
    labs(
      #title = paste("% Change 1992–2020 By", cols, sep= " "),
      x = NULL,
      y = "% Change"
    ) +
    theme_bw() +
    theme(
      strip.text = element_text(face = "bold", size = 10),
      axis.text.x = element_text(angle = 45, hjust = 1, size = 8)
    )
}

# Top/bottom 10 countries per service Send to the docuentnbsation, but we don't need to keep this here, just know thqat i is possible
# There are several filter types availalbe, jus add to the docuemtnaiton 
#plot_es_changes(plt_long, label_col = col, filter_type = "top_bottom", filter_val = 10)

# Top/bottom 5% per service
plot_es_changes(df, label_col = col, filter_type = "quantile", filter_val = 0.5)
# 
# # Show all values
# plot_es_changes(plt, filter_type = "all")
```

######################################################################################




# Violins


```{r fig.height=8, fig.width=10, warning=FALSE}
# 1. Define desired facet order

# 3. Reorder countries based on dir_ch_2 (descending)
df <- df %>%
  mutate(ee_r264_name = reorder(ee_r264_name, -dir_ch_2))
df. <- df %>% filter(service != "GDP") %>% filter(service != "Pop_sqkm")
# 4. Create plot
p <- ggplot(df., aes(x = ee_r264_name, y = pct_ch_trans, fill = ee_r264_name)) +
  geom_violin(trim = FALSE, scale = "width") +
  facet_wrap(~ service, scales = "free_y") +
  scale_fill_viridis_d(option = "D") +
  labs(
    title = "Pseudo-log Scaled % Change by Service ",
    x = NULL,
    y = "Transformed % Change"
  ) +
  theme_minimal() +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1, size = 8),
    strip.text = element_text(face = "bold"),
    legend.position = "none"
  )
# 4. Create plot
p2 <- ggplot(df, aes(x = ee_r264_name, y = pct_ch, fill = ee_r264_name)) +
  geom_violin(trim = FALSE, scale = "width") +
  facet_wrap(~ service, scales = "free_y") +
  scale_fill_viridis_d(option = "D") +
  labs(
    title = "% Change by Service ",
    x = NULL,
    y = "Transformed % Change"
  ) +
  theme_minimal() +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1, size = 8),
    strip.text = element_text(face = "bold"),
    legend.position = "none"
  )
p
p2

```

#######################

## 5. Here, add plots with the differences 

```{r eval=FALSE, fig.height=8, fig.width=14, include=FALSE}
print(col)
print(names(df))
stopifnot(col %in% names(df))

col <- "HYBAS_ID"
# Top/bottom 10 countries per service
plot_es_changes(df, label_col = col, filter_type = "top_bottom", filter_val = 10)

# Top/bottom 5% per service
plot_es_changes(df, label_col = col, filter_type = "quantile", filter_val = 0.1)

# Show all values
#plot_es_changes(plt, filter_type = "all")
```


## Scatterplots

```{r}


# List of LC metrics to analyze
lc_metrics <- c("Gain_2", "Persistence_2", "Loss_2", "dir_ch_2")

# Loop over each LC metric and generate a faceted scatterplot
for (metric in lc_metrics) {
  p <- plt %>%
    ggplot(aes_string(x = metric, y = "pct_ch", color = "color")) +
    geom_point(alpha = 0.5, size = 1.2) +
    facet_wrap(~ service, scales = "free") +
    scale_color_identity() +
    labs(
      title = paste("Relationship Between", metric, "and ES % Change"),
      x = metric,
      y = "% Change in Ecosystem Service"
    ) +
    theme_minimal() +
    theme(
      strip.text = element_text(face = "bold"),
      plot.title = element_text(hjust = 0.5),
      axis.text = element_text(size = 9)
    )

  print(p)
}
```


# Scatterplots change 2

```{r, fig.height=8, fig.width=14}


# LC metrics of interest
lc_metrics <- c("Gain_2", "Persistence_2", "Loss_2", "dir_ch_2")

# Step 1: Remove top 2% outliers for each service
filtered_plt <- plt %>%
  group_by(service) %>%
  mutate(threshold = quantile(pct_ch, 0.98, na.rm = TRUE)) %>%
  ungroup() %>%
  filter(pct_ch <= threshold)

# # Step 2: Apply pseudo-log transformation
# filtered_plt <- filtered_plt %>%
#   mutate(pct_ch_log = sign(pct_ch) * log1p(abs(pct_ch)))

# Step 3: Loop through each LC metric and create faceted plots
for (metric in lc_metrics) {
  p <- ggplot(filtered_plt, aes_string(x = metric, y = "pct_ch", color = "color")) +
    geom_point(alpha = 0.5, size = 1.2) +
    facet_wrap(~ service, scales = "free") +
    scale_color_identity() +
    labs(
      title = paste("Log-Transformed % Change vs", metric),
      x = metric,
      y = "Log(% Change in ES)"
    ) +
    theme_minimal() +
    theme(
      strip.text = element_text(face = "bold"),
      plot.title = element_text(hjust = 0.5),
      axis.text = element_text(size = 9)
    )

  print(p)
}
```

```{r, fig.height=8, fig.width=14}
# library(dplyr)
# library(ggplot2)
# 
# plt <- as_tibble(read.csv(here('output_data', "metrics_change_hb_lev_6.csv")))
# plt[1] <- NULL 
# # apply filter (5 or 2%) # Remove the smalles basins. That help. Also, it seems that some biomes are more prone to artifacts than others!!!
# area_threshold <- quantile(plt$SUB_AREA, probs = 0.05, na.rm = TRUE)
# # Filter the dataset
# df <- plt %>% filter(SUB_AREA > area_threshold)
# 
# 
# t_5 <- ggplot(df, aes(x = service, y = pct_ch, fill = color)) +
#   geom_boxplot() +  # or geom_violin()
#   scale_fill_identity() +
#   facet_wrap(~ service, scales = "free_y") +
#   labs(
#     title = "Distribution of % Change by Service (Excl. Smallest 5% of Basins)",
#     x = NULL,
#     y = "Percentage Change"
#   ) +
#   theme_minimal() +
#   theme(
#     axis.text.x = element_blank(),
#     strip.text = element_text(face = "bold"),
#     legend.position = "none"
#   )
# 
# library(ggplot2)
# library(dplyr)
# 
# # Custom pseudo-log transformation
# pseudo_log <- function(x) sign(x) * log1p(abs(x))
# 
# # Apply to the filtered dataframe
# df <- plt %>% 
#   mutate(pct_ch_trans = pseudo_log(pct_ch))
# 
# # Plot with transformed values
# p <- ggplot(df, aes(x = service, y = pct_ch_trans, fill = color)) +
#   geom_violin(trim = FALSE, scale = "width") +
#   scale_fill_identity() +
#   facet_wrap(~ service, scales = "free_y") +
#   labs(
#     title = "Pseudo-log Scaled % Change by Service",
#     x = NULL,
#     y = "Transformed % Change"
#   ) +
#   theme_minimal() +
#   theme(
#     axis.text.x = element_blank(),
#     strip.text = element_text(face = "bold"),
#     legend.position = "none"
#   )
# p
```

```{r leaflet 2}

# Load libraries
# Load libraries
library(sf)
library(dplyr)
library(tidyr)
library(leaflet)
library(RColorBrewer)
library(htmltools)

# Create separate boolean columns for each service being a hotspot
for (svc in services) {
  spring_ES[[paste0("is_", svc, "_hotspot")]] <- grepl(svc, spring_ES$hotspot_services)
}
# ---------------------------------------------
# Step 1. Define services to include in the map
# ---------------------------------------------
services <- c(
  "sed_export_pct_ch", "Usle_pct_ch", "Sed_retention_ratio_pct_ch",
  "Coastal_Protection_pct_ch", "Pollination_pct_ch", "N_export_pct_ch_2020_1992_sqkm"
)

# ---------------------------------------------
# Step 2. Fix malformed hotspot_services column
# ---------------------------------------------
# Final safe parser for all cases
parse_hotspot_services <- function(x) {
  if (is.null(x) || all(is.na(x))) return(NA_character_)
  if (is.character(x) && length(x) > 1) return(x)
  cleaned <- gsub("^c\\(|\\)$", "", x)                # remove c(...) wrapper
  cleaned <- gsub('[\\"\\\']', "", cleaned)           # remove quotes
  cleaned <- trimws(cleaned)
  strsplit(cleaned, ",\\s*")[[1]]
}

spring_ES_fixed <- spring_ES %>%
  mutate(hotspot_services = lapply(hotspot_services, parse_hotspot_services))

# ---------------------------------------------
# Step 3. Pivot to long format and filter to real hotspots
# ---------------------------------------------
spring_hotspots_long <- spring_ES_fixed %>%
  select(HYBAS_ID, geom, all_of(services), hotspot_services) %>%
  pivot_longer(cols = all_of(services), names_to = "service", values_to = "value") %>%
  mutate(
    is_hotspot = mapply(function(svc, hs) {
      if (is.null(hs) || all(is.na(hs))) return(FALSE)
      svc %in% hs
    }, service, hotspot_services),
    label = paste("HYBAS:", HYBAS_ID, "<br>Service:", service, "<br>Change:", round(value, 2))
  ) %>%
  filter(is_hotspot & !is.na(value)) %>%
  st_as_sf() %>%
  st_make_valid() %>%
  st_transform(4326)

# ---------------------------------------------
# Step 4. Define color palette (diverging red-blue)
# ---------------------------------------------
pal <- colorNumeric(
  palette = "RdBu",
  domain = spring_hotspots_long$value,
  reverse = TRUE
)

# ---------------------------------------------
# Step 5. Initialize leaflet map with base layers
# ---------------------------------------------
m <- leaflet(options = leafletOptions(preferCanvas = TRUE)) %>%
  addProviderTiles("OpenStreetMap.Mapnik", group = "OSM") %>%
  addProviderTiles("CartoDB.Positron", group = "Positron") %>%
  addProviderTiles("Esri.WorldImagery", group = "Satellite")

# ---------------------------------------------
# Step 6. Add a service-specific overlay per layer
# ---------------------------------------------
for (svc in unique(spring_hotspots_long$service)) {
  layer_data <- filter(spring_hotspots_long, service == svc)
  m <- m %>% addPolygons(
    data = layer_data,
    fillColor = ~pal(value),
    fillOpacity = 0.7,
    color = "black", weight = 0.3,
    label = ~lapply(label, HTML),
    group = svc
  )
}

# ---------------------------------------------
# Step 7. Add layer control and legend
# ---------------------------------------------
m <- m %>%
  addLayersControl(
    baseGroups = c("OSM", "Positron", "Satellite"),
    overlayGroups = unique(spring_hotspots_long$service),
    options = layersControlOptions(collapsed = FALSE)
  ) %>%
  addLegend(
    "bottomright",
    pal = pal,
    values = spring_hotspots_long$value,
    title = "% Change"
  )

# ---------------------------------------------
# Step 8. Render the map
# ---------------------------------------------
m

```

```{r leaflet 2}

# Load libraries
# Load libraries
library(sf)
library(dplyr)
library(tidyr)
library(leaflet)
library(RColorBrewer)
library(htmltools)

# Create separate boolean columns for each service being a hotspot
for (svc in services) {
  spring_ES[[paste0("is_", svc, "_hotspot")]] <- grepl(svc, spring_ES$hotspot_services)
}
# ---------------------------------------------
# Step 1. Define services to include in the map
# ---------------------------------------------
services <- c(
  "sed_export_pct_ch", "Usle_pct_ch", "Sed_retention_ratio_pct_ch",
  "Coastal_Protection_pct_ch", "Pollination_pct_ch", "N_export_pct_ch_2020_1992_sqkm"
)

# ---------------------------------------------
# Step 2. Fix malformed hotspot_services column
# ---------------------------------------------
# Final safe parser for all cases
parse_hotspot_services <- function(x) {
  if (is.null(x) || all(is.na(x))) return(NA_character_)
  if (is.character(x) && length(x) > 1) return(x)
  cleaned <- gsub("^c\\(|\\)$", "", x)                # remove c(...) wrapper
  cleaned <- gsub('[\\"\\\']', "", cleaned)           # remove quotes
  cleaned <- trimws(cleaned)
  strsplit(cleaned, ",\\s*")[[1]]
}

spring_ES_fixed <- spring_ES %>%
  mutate(hotspot_services = lapply(hotspot_services, parse_hotspot_services))

# ---------------------------------------------
# Step 3. Pivot to long format and filter to real hotspots
# ---------------------------------------------
spring_hotspots_long <- spring_ES %>%
  select(HYBAS_ID, geom, all_of(services)) %>%
  pivot_longer(cols = all_of(services), names_to = "service", values_to = "value") %>%
  filter(!is.na(value)) %>%
  mutate(
    label = paste("HYBAS:", HYBAS_ID, "<br>Service:", service, "<br>Change:", round(value, 2))
  ) %>%
  st_as_sf() %>%
  st_make_valid() %>%
  st_transform(4326)

# ---------------------------------------------
# Step 4. Define color palette (diverging red-blue)
# ---------------------------------------------
pal <- colorNumeric(
  palette = "RdBu",
  domain = spring_hotspots_long$value,
  reverse = TRUE
)

m <- leaflet(options = leafletOptions(preferCanvas = TRUE)) %>%
  addProviderTiles("OpenStreetMap.Mapnik", group = "OSM") %>%
  addProviderTiles("CartoDB.Positron", group = "Positron") %>%
  addProviderTiles("Esri.WorldImagery", group = "Satellite")

for (svc in unique(spring_hotspots_long$service)) {
  layer_data <- filter(spring_hotspots_long, service == svc)
  m <- m %>% addPolygons(
    data = layer_data,
    fillColor = ~pal(value),
    fillOpacity = 0.7,
    color = "black", weight = 0.3,
    label = ~lapply(label, HTML),
    group = svc
  )
}

m <- m %>%
  addLayersControl(
    baseGroups = c("OSM", "Positron", "Satellite"),
    overlayGroups = unique(spring_hotspots_long$service),
    options = layersControlOptions(collapsed = FALSE)
  ) %>%
  addLegend(
    "bottomright",
    pal = pal,
    values = spring_hotspots_long$value,
    title = "% Change"
  )

m

```

```{r leaflet 3}
# Create separate boolean columns for each service being a hotspot
for (svc in services) {
  spring_ES[[paste0("is_", svc, "_hotspot")]] <- grepl(svc, spring_ES$hotspot_services)
}
spring_hotspots_long <- spring_ES %>%
  select(HYBAS_ID, geom, all_of(services), starts_with("is_")) %>%
  pivot_longer(cols = all_of(services), names_to = "service", values_to = "value") %>%
  mutate(
    hotspot_flag = case_when(
      service == "sed_export_pct_ch" ~ is_sed_export_pct_ch_hotspot,
      service == "Usle_pct_ch" ~ is_Usle_pct_ch_hotspot,
      service == "Sed_retention_ratio_pct_ch" ~ is_Sed_retention_ratio_pct_ch_hotspot,
      service == "Coastal_Protection_pct_ch" ~ is_Coastal_Protection_pct_ch_hotspot,
      service == "Pollination_pct_ch" ~ is_Pollination_pct_ch_hotspot,
      service == "N_export_pct_ch_2020_1992_sqkm" ~ is_N_export_pct_ch_2020_1992_sqkm_hotspot,
      TRUE ~ FALSE
    ),
    label = paste("HYBAS:", HYBAS_ID, "<br>Service:", service, "<br>Change:", round(value, 2))
  ) %>%
  filter(hotspot_flag & !is.na(value)) %>%
  st_as_sf() %>%
  st_make_valid() %>%
  st_transform(4326)
pal <- colorNumeric(
  palette = "RdBu",
  domain = spring_hotspots_long$value,
  reverse = TRUE
)

m <- leaflet(options = leafletOptions(preferCanvas = TRUE)) %>%
  addProviderTiles("OpenStreetMap.Mapnik", group = "OSM") %>%
  addProviderTiles("CartoDB.Positron", group = "Positron") %>%
  addProviderTiles("Esri.WorldImagery", group = "Satellite")

for (svc in unique(spring_hotspots_long$service)) {
  layer_data <- filter(spring_hotspots_long, service == svc)
  m <- m %>% addPolygons(
    data = layer_data,
    fillColor = ~pal(value),
    fillOpacity = 0.7,
    color = "black", weight = 0.3,
    label = ~lapply(label, HTML),
    group = svc
  )
}

m <- m %>%
  addLayersControl(
    baseGroups = c("OSM", "Positron", "Satellite"),
    overlayGroups = unique(spring_hotspots_long$service),
    options = layersControlOptions(collapsed = FALSE)
  ) %>%
  addLegend(
    "bottomright",
    pal = pal,
    values = spring_hotspots_long$value,
    title = "% Change"
  )

m
```

```{r fig.height=8, fig.width=10, warning=FALSE}
library(dplyr)
library(ggplot2)
library(forcats)

# 1. Filter the dataframe for top and bottom 10 by dir_ch_2
df_top_bottom <- df %>%
  arrange(desc(dir_ch_2)) %>%
  slice_head(n = 10) %>%
  bind_rows(
    df %>%
      arrange(dir_ch_2) %>%
      slice_head(n = 10)
  )

# 2. Reorder countries inside the filtered data
df_top_bottom <- df_top_bottom %>%
  mutate(ee_r264_name = fct_reorder(ee_r264_name, -dir_ch_2))
df_top_bottom <- df_top_bottom %>% filter(service != "GDP") %>% filter(service != "Pop_sqkm")

# 3. Create plot (pseudo-log scale)
p <- ggplot(df_top_bottom, aes(x = ee_r264_name, y = pct_ch_trans, fill = service)) +
  geom_violin(trim = FALSE, scale = "width") +
  facet_wrap(~ service, scales = "free_y") +
  scale_fill_viridis_d(option = "D") +
  labs(
    title = "Pseudo-log Scaled % Change by Service (Top and Bottom 10 Countries)",
    x = NULL,
    y = "Transformed % Change"
  ) +
  theme_minimal() +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1, size = 8),
    strip.text = element_text(face = "bold"),
    legend.position = "right"
  )

# 4. (Optional) Plot regular % change
p2 <- ggplot(df_top_bottom, aes(x = ee_r264_name, y = pct_ch, fill = service)) +
  geom_violin(trim = FALSE, scale = "width") +
  facet_wrap(~ service, scales = "free_y") +
  scale_fill_viridis_d(option = "D") +
  labs(
    title = "% Change by Service (Top and Bottom 10 Countries)",
    x = NULL,
    y = "% Change"
  ) +
  theme_minimal() +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1, size = 8),
    strip.text = element_text(face = "bold"),
    legend.position = "right"
  )

# 5. Print
p
# p2  # if you also want the regular % plot

```




