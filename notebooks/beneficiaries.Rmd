---
title: "Beneficiary consolidation
output: html_notebook
---
# Zonal Stat Exctraction and exploratory analysis 

```{r setup, message=FALSE, warning=FALSE}
library(terra)
library(sf)
library(dplyr)
library(ggplot2)
library(glue)
library(tidyr)
library(purrr)
library(diffeR)
library(here)
library(stringr)
library(tidytext)
library(rlang)
library(tidyr)
library(forcats)
library(scales)
library(RColorBrewer)
library(htmltools)
library(leaflet)
library(devtools)
load_all()
#source the helper functions
source(here("R", "hotSpotR.R"))
source(here("R","utils_pct_change.R"))
source(here("R", "utils_lcc_metrics.R"))
source(here("R","utils_pct_change.R"))
source(here("R", "perc_filteR.R"))
```

I moved some chunks from here to the end of **Consolidation.Rmd**. They kept distracting me and making me waste even more time each time i had to make sense of this, and the worst , wasting time. I will move what was here away to avoid getting confused (again), but keep record where i put in case i ever need to review this. If at some point that is not necessary anymore, i will move that to old_notebook, but for the love of Bochica, keep our working spaces clean !!

 I moved some chunks from here to the end of **Consolidation.Rmd**. They kept distracting me and making me waste even more time each time i had to make sens of this, and the worst , wasting time. I will move wha was here away to avoidgetting confused (again), but kep record where i put in csase i ever need to review this. If at some point that is nto neceesary anymore, i will move that to old_notebook, but for the love of Bochica, keep our working spaces clean !!


Here, another dialogue to input the variable names, plot colors and set the factor order.
Find out why i did this!!!
Load the input ecosystem service data for the final priortized Ecosysye Service Change Data */output_data/metrics_change_hb_lev_6.csv* 
By 19/05/2025 it contains. change values for following ES datalayers synthetzed at the Basin_lv6: 

"Sed_export"         "Sed_Ret_Ratio"      "Coastal_Protection" "Pollination"        "N_export"           "Pop_sqkm"           "GDP"                "N_Ret_Ratio"
 

#####################################

Start HERE!!!!

```{r setup}
# ---------------------------------------------------------
# SETUP: Load Ecosystem Service - Beneficiary Data
# ---------------------------------------------------------

# Load long-format ES data (one row per basin-service-metric)
df_raw <- read_csv(here("output_data", "serv_benef_synth_01.csv"))
df_raw <- read.csv('/Users/rodriguez/Library/CloudStorage/OneDrive-WorldWildlifeFund,Inc/global_NCP/output_data/serv_benef_synth_01.csv')
# ---------------------------------------------------------
# STEP 1: Filter out small basins by SUB_AREA
# ---------------------------------------------------------

# ---- USER OPTIONS ----
filter_type <- "quantile"   # Options: "quantile", "percent", "absolute"
filter_cutoff <- 0.05       # 5% cutoff if using quantile or percent
filter_direction <- "bottom"  # Options: "bottom", "top", "both", "none"
# -----------------------

# Compute threshold based on filter type
if (filter_type == "quantile") {
  area_threshold <- quantile(df_raw$SUB_AREA, probs = filter_cutoff, na.rm = TRUE)
} else if (filter_type == "percent") {
  n_threshold <- ceiling(nrow(df_raw) * filter_cutoff)
  area_threshold <- df_raw %>%
    arrange(SUB_AREA) %>%
    pull(SUB_AREA) %>%
    {.[n_threshold]}
} else if (filter_type == "absolute"){
  area_threshold <- filter_cutoff}


# Compute thresholds
if (filter_type == "quantile") {
  q_val <- quantile(df_raw$SUB_AREA, probs = c(filter_cutoff, 1 - filter_cutoff), na.rm = TRUE)
} else if (filter_type == "percent") {
  sorted_areas <- df_raw %>% arrange(SUB_AREA) %>% pull(SUB_AREA)
  n_total <- length(sorted_areas)
  n_cut <- ceiling(n_total * filter_cutoff)
  q_val <- c(sorted_areas[n_cut], sorted_areas[n_total - n_cut])
} else if (filter_type == "absolute") {
  q_val <- c(filter_cutoff, max(df_raw$SUB_AREA))
} else {
  stop("Invalid filter_type: must be 'quantile', 'percent', or 'absolute'")
}

# Apply filtering logic
df <- df_raw

if (filter_direction == "bottom") {
  df <- df %>% filter(SUB_AREA > area_threshold)
  filter_note <- paste0("Filtered: Smallest ", round(100 * filter_cutoff), "% basins removed")
} else if (filter_direction == "top") {
  df <- df %>% filter(SUB_AREA < area_threshold)
  filter_note <- paste0("Filtered: Largest ", round(100 * filter_cutoff), "% basins removed")
} else if (filter_direction == "both") {
  q_low <- quantile(df_raw$SUB_AREA, probs = filter_cutoff / 2, na.rm = TRUE)
  q_high <- quantile(df_raw$SUB_AREA, probs = 1 - filter_cutoff / 2, na.rm = TRUE)
  df <- df %>% filter(SUB_AREA > q_low & SUB_AREA < q_high)
  filter_note <- paste0("Filtered: Smallest and largest ", round(100 * (filter_cutoff / 2)), "% basins removed")
}
if (filter_direction == "top") {
  df <- df %>% filter(SUB_AREA >= q_val[2])
  filter_note <- paste0("Top ", round(100 * filter_cutoff), "% largest basins")
} else if (filter_direction == "bottom") {
  df <- df %>% filter(SUB_AREA <= q_val[1])
  filter_note <- paste0("Bottom ", round(100 * filter_cutoff), "% smallest basins")
} else if (filter_direction == "both") {
  df <- df %>% filter(SUB_AREA <= q_val[1] | SUB_AREA >= q_val[2])
  filter_note <- paste0("Top & bottom ", round(100 * filter_cutoff), "% basins")
} else if (filter_direction == "tail") {
  df <- df %>% filter(SUB_AREA <= q_val[1] | SUB_AREA >= q_val[2])
  filter_note <- paste0("Filtered: Extreme tails (", round(100 * filter_cutoff), "%)")
} else if (filter_direction == "middle") {
  df <- df %>% filter(SUB_AREA > q_val[1] & SUB_AREA < q_val[2])
  filter_note <- paste0("Filtered: Middle ", round(100 * (1 - 2 * filter_cutoff)), "% of basins")
} else {
  filter_note <- "No basin size filtering applied"
}

# ---------------------------------------------------------
# STEP 2: Set Service Order and Colors
# ---------------------------------------------------------
service_levels <- c("Coastal_Protection", "N_export", "Sed_export",
                    "Pollination", "N_Ret_Ratio", "Sed_Ret_Ratio")

service_colors <- c("#9e9ac8", "#dd1c77", "#2c944c",
                    "#2c711c", "#08306b", "#02606b")


df <- df %>%
  mutate(service = factor(service, levels = service_levels))

# ---------------------------------------------------------
# STEP 3: Define LC Metric Labels for Plotting
# ---------------------------------------------------------
lc_metrics <- c(
  "rast_gdpTot_1990_2020_30arcsec.7_mean",
  "GHS_POP_E2020_GLOBE_R2023A_4326_3ss_V1_0.1_mean",
  "GlobPOP_Count_30arc_2020_I32.1_sum",
  "hdi_raster_predictions_2020.1_mean",
  "farmsize_mehrabi.1_mean",
  "GlobPOP_sqkm",
  "dir_ch_2"
)

lc_labels <- c(
  "Mean GDP 2020",
  "GHS Population Mean 2020",
  "GlobPop Sum 2020",
  "Mean HDI 2020",
  "Farmsize 2017",
  "GlobPop/km²",
  "Land Cover Change"
)

nam <- tibble(lc_metrics = lc_metrics, names = lc_labels)

# ---------------------------------------------------------
# ✅ READY: `df` is your filtered dataset
#         `nam` is your label lookup
#         `filter_note` is your subtitle / filename tag
# ---------------------------------------------------------


```

# run it 

```{r run_scatter}
plot_es_lc_scatter(
  df = df,
  lc_metrics = lc_metrics,
  nam = nam,
  export_dir = here::here("output_charts"),
  filter_note = filter_note
)
```

## Scatterplots
 Ready the data (load and adjust symbols
```{r other plot}
#load the ecosysytem service dsata in long format
plt <- as_tibble(read.csv(here("output_data", "serv_benef_synth_01.csv")))

# get the filtered locations
area_threshold <- quantile(plt$SUB_AREA, probs = 0.05, na.rm = TRUE)
# Filter the dataset. Remove smallest 5% of the basins
df <- plt %>% filter(SUB_AREA > area_threshold)
# Set the levesl. This seems banal; but is important because iut defines how the layer facets will be rendered. Is also annoying because i can't think about a way to do it which is 
# 3 Columns, 2 Rows:
service <- c("Coastal_Protection","N_export","Sed_export","Pollination","N_Ret_Ratio","Sed_Ret_Ratio")
 color <- c("#9e9ac8", "#dd1c77","#2c944c", "#2c711c","#08306b", "#02606b")
 service_levels <- service

df <- df %>%
  mutate(
    service = factor(service, levels = service_levels),
  )

# 3. List of Benef data to analyze. We can profit and set the names here. I am thinking about the best sat to get (sum/mean. Is not as evident as it seems at first) 
lc_metrics <- c("rast_gdpTot_1990_2020_30arcsec.7_mean","GHS_POP_E2020_GLOBE_R2023A_4326_3ss_V1_0.1_mean","GlobPOP_Count_30arc_2020_I32.1_sum","hdi_raster_predictions_2020.1_mean","farmsize_mehrabi.1_mean","GlobPOP_sqkm","dir_ch_2")
names <- c("Mean GDP 2020", "GHS Population Mean 2020", "GlobPop Sum 2020", "Mean HDI 2020", "Farmsize 2017", "GlobPop/kmˆ2", "LCover Change")
nam <- as_tibble(cbind(lc_metrics,names))
```



```{r scatterplots 2, fig.height=8, fig.width = 11}

plot_es_lc_scatter(
  df = df,
  lc_metrics = nam$lc_metrics,
  nam = nam,
reverse_axes = TRUE,
  #export_dir = here::here("output_charts")
)



```

```{r filtered, fig.height=8, fig.width = 11}

# Define services where we want the largest losses (negative change is bad)
loss_services <- c("Coastal_Protection", "Pollination", "N_Ret_Ratio", "Sed_Ret_Ratio")

# Define services where we want the largest gains (positive change is bad, e.g. sediment/nutrient export)
gain_services <- c("Sed_export", "N_export")

# Create a new column where we flip the sign only for gain services
df <- df %>%
  mutate(
    pct_ch_focus = case_when(
      service %in% gain_services ~ pct_ch,         # positive values are bad → keep as-is
      service %in% loss_services ~ -pct_ch,        # negative values are bad → flip sign
      TRUE ~ pct_ch                                 # fallback
    )
  )

# Now get the top 5% of "problematic" changes
df_hotspots <- df %>%
  group_by(service) %>%
  mutate(threshold = quantile(pct_ch_focus, 0.95, na.rm = TRUE)) %>%
  ungroup() %>%
  filter(pct_ch_focus >= threshold)



# df_f <- df %>%
#   group_by(service) %>%
#   mutate(threshold = quantile(pct_ch, 0.05, na.rm = TRUE)) %>%
#   ungroup() %>%
#   filter(pct_ch <= threshold)
# 

plot_es_lc_scatter(
  df = df_hotspots,
  lc_metrics = nam$lc_metrics,
  nam = nam,
  #xport_dir = here::here("output_charts"),
reverse_axes = FALSE,
  filter_note = "top % change per service"
)
```

```{r filtered, fig.height=9, fig.width = 12}
# ✅ READY: Filtered Data + Labels + Notes
# ---------------------------------------------------------
# df          -> the filtered data
# nam         -> label table for plotting
# filter_note -> subtitle for plots

# To run the plotting function:
# plot_es_lc_scatter(df = df, lc_metrics = lc_metrics, nam = nam, filter_note = filter_note)

# ---------------------------------------------------------
# 👩‍🏫 QUICK CLARIFICATION: Percentile vs. Top X%
# ---------------------------------------------------------
# - "95th percentile" means the value **below which 95% of the data falls**.
#   → You use this **value as a threshold** to keep/remove rows.
#
# - "Top 5%" means selecting the **actual top 5% of rows** (usually sorted).
#   → This is a count-based filter: you select N rows from the top.
#
# ✅ They are similar *if the data is continuous and large*, but not identical.
# ✅ Use `quantile()` for value-based filtering; use `arrange()` + slice/count for count-based.
# ---------------------------------------------------------

# ---------------------------------------------------------
# RUN DIFFERENT FILTERING SCENARIOS
# ---------------------------------------------------------
prep_none <- filter_and_prepare_df(df_raw, filter_direction = "none", service_levels = service_levels, metric_labels = nam)
prep_top <- filter_and_prepare_df(df_raw, filter_cutoff = 0.95, filter_direction = "top", service_levels = service_levels, metric_labels = nam)

```





```{r scatterplots 2, fig.height=6, fig.width = 9}
plot_es_lc_scatter(
  df = prep_top$df,
  lc_metrics = lc_metrics,
  nam = prep_none$nam,
  filter_note = prep_none$filter_note,
  reverse_axes = FALSE,
  apply_log = FALSE,
  remove_outliers = TRUE,
 #export_dir = here("output_charts"))

```


```{r scatterplots 3, fig.height=6, fig.width = 9}
plot_es_lc_scatter(
  df = prep_top$df,
  lc_metrics = lc_metrics,
  nam = prep_none$nam,
  filter_note = prep_none$filter_note,
  reverse_axes = TRUE,
  apply_log = FALSE,
  remove_outliers = TRUE)
```


```{r get_hotspots, fig.height=6, fig.width = 9}
get_hotspot_df <- function(df, change_var = "pct_ch", cutoff = 0.05) {
  df %>%
    group_by(service) %>%
    mutate(
      low_cut = quantile(.data[[change_var]], probs = cutoff / 2, na.rm = TRUE),
      high_cut = quantile(.data[[change_var]], probs = 1 - cutoff / 2, na.rm = TRUE)
    ) %>%
    ungroup() %>%
    filter(.data[[change_var]] <= low_cut | .data[[change_var]] >= high_cut)
}


df_hotspots <- get_hotspot_df(prep_top$df)

plot_es_lc_scatter(
  df = df_hotspots,
  lc_metrics = lc_metrics,
  nam = prep_top$nam,
  filter_note = "Hotspots: Top/Bottom 5% Change",
  remove_outliers = TRUE             # Keeps plot readable
)

```


# ---- USER OPTIONS ----
filter_type <- "percent"   # Options: "quantile", "percent", "absolute"
filter_cutoff <-0.05       # 5% cutoff if using quantile or percent
filter_direction <- "top"  # Options: "bottom", "top", "both", "none"
# -----------------------

plot_es_lc_scatter(
  df = df,
geom_type = "hex", bins = 80,
  lc_metrics = nam$lc_metrics,
  nam = nam,
  export_dir = NULL,
flip_axes = FALSE#here::here("output_charts")
)


# 
# df_f <- df %>%
#   group_by(service) %>%
#   mutate(threshold = quantile(pct_ch, 0.95, na.rm = TRUE)) %>%
#   ungroup() %>%
#   filter(pct_ch <= threshold)
# 
# 
# plot_es_lc_scatter(
#   df = df_f,
# geom_type = "hex", bins = 40,
#   lc_metrics = nam$lc_metrics,
#   nam = nam,
#   #export_dir = here::here("output_charts"),
#   filter_note = "Filtered: Top 95% of observations"
# )
# 

```

```{r scatterplots 2, fig.height=9, fig.width = 12}


# ---- USER OPTIONS ----
filter_type <- "percent"   # Options: "quantile", "percent", "absolute"
filter_cutoff <-0.05       # 5% cutoff if using quantile or percent
filter_direction <- "both"  # Options: "bottom", "top", "both", "none"
# -----------------------

plot_es_lc_scatter(
  df = df,
geom_type = "hex", bins = 80,
  lc_metrics = nam$lc_metrics,
  nam = nam,
  export_dir = NULL,
flip_axes = FALSE#here::here("output_charts")
)



df_f <- df %>%
  group_by(service) %>%
  mutate(threshold = quantile(pct_ch, 0.95, na.rm = TRUE)) %>%
  ungroup() %>%
  filter(pct_ch <= threshold)


plot_es_lc_scatter(
  df = df_f,

  lc_metrics = nam$lc_metrics,
  nam = nam,
  #xport_dir = here::here("output_charts"),
  filter_note = "Filtered: Top 95% of observations"
)

geom_type = "hex", bins = 40,
  lc_metrics = nam$lc_metrics,
  nam = nam,
  #export_dir = here::here("output_charts"),
  filter_note = "Filtered: Top 95% of observations"
)


```

###########################################################


```{r fig.height=8, fig.width=10, warning=FALSE}
library(dplyr)

# 1. Identify hotspots by service
df_hotspots <- df %>%
  group_by(service) %>%
  mutate(
    upper_threshold = quantile(pct_ch, 0.999, na.rm = TRUE),
    lower_threshold = quantile(pct_ch, 0.001, na.rm = TRUE),
    hotspot_flag = case_when(
      pct_ch >= upper_threshold ~ "high",
      pct_ch <= lower_threshold ~ "low",
      TRUE ~ NA_character_
    ),
    hotspot_binary = !is.na(hotspot_flag)
  ) %>%
  ungroup()

# 2. Count how many times each HYBAS_ID is a hotspot
hotspot_summary <- df_hotspots %>%
  filter(hotspot_binary) %>%
  group_by(HYBAS_ID) %>%
  summarise(
    hotspot_count = n(),
    hotspot_services = list(unique(service))
  )
hotspot_summary <- hotspot_summary %>%
  mutate(hotspot_services = lapply(hotspot_services, \(x) trimws(as.character(x))),
         hotspot_services = sapply(hotspot_services, \(x) paste(x, collapse = ", ")))

spring_ES <- spring_ES %>%
  mutate(HYBAS_ID = as.double(HYBAS_ID))

spring_ES <- left_join(spring_ES, hotspot_summary, by = "HYBAS_ID")

#st_write(spring_ES, here('vector', "hydrosheds_lv_6_hotspots.gpkg"))
```

# Create maps
```{r create_maps}
# Load libraries
library(sf)
library(dplyr)
library(tidyr)
library(leaflet)
library(RColorBrewer)
library(htmltools)

spring_ES <- st_read(here('vector', "hydrosheds_lv_6_hotspots.gpkg"))

spring_ES <- st_read('/Users/rodriguez/Library/CloudStorage/OneDrive-WorldWildlifeFund,Inc/global_NCP/data/vector/hydrosheds_lv_6_hotspots.gpkg')
>>>>>>> cb7af26 (Adjusted Scatterplots for meeting 27/05. Pendibg refibe (impacts/losses only))
# ---------------------------------------------
# Step 1. Define services to include in the map
# ---------------------------------------------
services <- c(
  "sed_export_pct_ch", "Usle_pct_ch", "Sed_retention_ratio_pct_ch",
  "Coastal_Protection_pct_ch", "Pollination_pct_ch", "N_export_pct_ch_2020_1992_sqkm"
)

# ---------------------------------------------
# Step 2. Prepare data: pivot and clean
# ---------------------------------------------
spring_hotspots_long <- spring_ES %>%
  select(HYBAS_ID, geom, all_of(services)) %>%
  pivot_longer(
    cols = all_of(services),
    names_to = "service",
    values_to = "value"
  ) %>%
  filter(!is.na(value) & is.finite(value)) %>%
  mutate(
    label = paste("HYBAS:", HYBAS_ID,
                  "<br>Service:", service,
                  "<br>Change:", round(value, 2))
  ) %>%
  st_as_sf() %>%
  st_make_valid() %>%
  st_transform(4326)

# ---------------------------------------------
# Step 3. Define color palette (diverging red-blue)
# ---------------------------------------------
pal <- colorNumeric(
  palette = "RdBu",
  domain = spring_hotspots_long$value,
  reverse = TRUE
)

# ---------------------------------------------
# Step 4. Initialize leaflet map with base layers
# ---------------------------------------------
m <- leaflet(options = leafletOptions(preferCanvas = TRUE)) %>%
  addProviderTiles("OpenStreetMap.Mapnik", group = "OSM") %>%
  addProviderTiles("CartoDB.Positron", group = "Positron") %>%
  addProviderTiles("Esri.WorldImagery", group = "Satellite")

# ---------------------------------------------
# Step 5. Add a service-specific overlay per layer
# ---------------------------------------------
for (svc in unique(spring_hotspots_long$service)) {
  layer_data <- filter(spring_hotspots_long, service == svc)
  m <- m %>% addPolygons(
    data = layer_data,
    fillColor = ~pal(value),
    fillOpacity = 0.7,
    color = "black", weight = 0.3,
    label = ~lapply(label, HTML),
    group = svc
  )
}

# ---------------------------------------------
# Step 6. Add layer control and legend
# ---------------------------------------------
m <- m %>%
  addLayersControl(
    baseGroups = c("OSM", "Positron", "Satellite"),
    overlayGroups = unique(spring_hotspots_long$service),
    options = layersControlOptions(collapsed = FALSE)
  ) %>%
  addLegend(
    "bottomright",
    pal = pal,
    values = spring_hotspots_long$value,
    title = "% Change"
  )

# ---------------------------------------------
# Step 7. Render the map
# ---------------------------------------------
m


```

# light version

```{r light version}

# Load libraries (if not already loaded)
library(sf)
library(dplyr)
library(tidyr)
library(leaflet)
library(RColorBrewer)
library(htmltools)

# ---------------------------------------------
# Step 1. Define services to include in the map
# ---------------------------------------------
services <- c(
  "sed_export_pct_ch", "Usle_pct_ch", "Sed_retention_ratio_pct_ch",
  "Coastal_Protection_pct_ch", "Pollination_pct_ch", "N_export_pct_ch_2020_1992_sqkm"
)

# ---------------------------------------------
# Step 2. Pivot data and filter only one service + sample
# ---------------------------------------------
# Choose service to visualize (change as needed)
target_service <- "Sed_retention_ratio_pct_ch"

spring_hotspots_sample <- spring_ES %>%
  select(HYBAS_ID, geom, all_of(target_service)) %>%
  rename(value = !!target_service) %>%
  filter(!is.na(value) & is.finite(value)) %>%
  slice_sample(n = 5000) %>%
  mutate(
    service = target_service,
    label = paste("HYBAS:", HYBAS_ID,
                  "<br>Service:", service,
                  "<br>Change:", round(value, 2))
  ) %>%
  st_as_sf() %>%
  st_make_valid() %>%
  st_transform(4326)

# ---------------------------------------------
# Step 3. Define color palette (diverging red-blue)
# ---------------------------------------------
pal <- colorNumeric(
  palette = "RdBu",
  domain = spring_hotspots_sample$value,
  reverse = FALSE
)

# ---------------------------------------------
# Step 4. Build fast interactive map
# ---------------------------------------------
m <- leaflet(options = leafletOptions(preferCanvas = TRUE)) %>%
  addProviderTiles("CartoDB.Positron", group = "Positron") %>%
  addPolygons(
    data = spring_hotspots_sample,
    fillColor = ~pal(value),
    fillOpacity = 0.7,
    color = "black", weight = 0.3,
    label = ~lapply(label, HTML),
    group = target_service
  ) %>%
  addLayersControl(
    baseGroups = c("Positron"),
    overlayGroups = c(target_service),
    options = layersControlOptions(collapsed = FALSE)
  ) %>%
  addLegend(
    "bottomright",
    pal = pal,
    values = spring_hotspots_sample$value,
    title = "% Change"
  )

# ---------------------------------------------
# Step 5. Show the map
# ---------------------------------------------
m

```

# 3. Reorder countries based on dir_ch_2 (descending)
```{r }
df <- df %>%
  mutate(ee_r264_name = reorder(ee_r264_name, -dir_ch_2))
# 4. Create plot
p <- ggplot(df, aes(x = ee_r264_name, y = pct_ch_trans, fill = ee_r264_name)) +
  geom_violin(trim = FALSE, scale = "width") +
  facet_wrap(~ service, scales = "free_y") +
  scale_fill_viridis_d(option = "D") +
  labs(
    title = "Pseudo-log Scaled % Change by Service ",
    x = NULL,
    y = "Transformed % Change"
  ) +
  #theme_minimal() +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1, size = 8),
    strip.text = element_text(face = "bold"),
    legend.position = "none"
  )
# 4. Create plot
p2 <- ggplot(df, aes(x = ee_r264_name, y = pct_ch, fill = ee_r264_name)) +
  geom_violin(trim = FALSE, scale = "width") +
  facet_wrap(~ service, scales = "free_y") +
  scale_fill_viridis_d(option = "D") +
  labs(
    title = "% Change by Service ",
    x = NULL,
    y = "Transformed % Change"
  ) +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1, size = 8),
    strip.text = element_text(face = "bold"),
    legend.position = "none"
  )
p
p2

```
######################################################################################
## 5. add plots with the differences 

Convert into function. We don't need this right now!!!
```{r, fig.height=8, fig.width=14}
col <- "HYBAS_ID"
# create thew function. THIS is what i need to get righ (save as a function)
plot_es_changes <- function(data, label_col, #labelr col has the column with the ind IDs.
                            filter_type = "top_bottom", filter_val = 10) {
  label_sym <- sym(label_col)
  # Step 2: Apply filtering based on the chosen type
  if (filter_type == "top_bottom") {
    # Top/bottom n observations per service
    top_bottom <- data %>%
      group_by(service) %>%
      slice_max(pct_ch, n = filter_val, with_ties = FALSE) %>%
      bind_rows(
        data %>%
          group_by(service) %>%
          slice_min(pct_ch, n = filter_val, with_ties = FALSE)
      ) %>%
      ungroup()

  } else if (filter_type == "quantile") {
    # Top/bottom quantile per service (e.g., top/bottom 10%)
    top_bottom <- data %>%
      group_by(service) %>%
      filter(pct_ch >= quantile(pct_ch, 1 - filter_val, na.rm = TRUE) |
             pct_ch <= quantile(pct_ch, filter_val, na.rm = TRUE)) %>%
      ungroup()

  } else if (filter_type == "all") {
    top_bottom <- data
  } else {
    stop("Invalid `filter_type`. Use 'top_bottom', 'quantile', or 'all'.")
  }

  # Step 3: Reorder labels per service ## This is stupid. Better to order the labels outside
  top_bottom <- top_bottom %>%
    mutate(temp_label = reorder_within(!!label_sym, -pct_ch, service))

  # Step 4: Plot
  ggplot(top_bottom, aes(x = temp_label, y = pct_ch)) +#, fill = color)) +
    geom_bar(stat = "identity", show.legend = FALSE) +
    scale_fill_identity() +
    scale_x_reordered() +
    facet_wrap(~ service, scales = "free", ncol = 3) +
    labs(
      #title = paste("% Change 1992–2020 By", cols, sep= " "),
      x = NULL,
      y = "% Change"
    ) +
    theme_bw() +
    theme(
      strip.text = element_text(face = "bold", size = 10),
      axis.text.x = element_text(angle = 45, hjust = 1, size = 8)
    )
}

# Top/bottom 10 countries per service Send to the docuentnbsation, but we don't need to keep this here, just know thqat i is possible
# There are several filter types availalbe, jus add to the docuemtnaiton 
#plot_es_changes(plt_long, label_col = col, filter_type = "top_bottom", filter_val = 10)

# Top/bottom 5% per service
plot_es_changes(df, label_col = col, filter_type = "quantile", filter_val = 0.5)
# 
# # Show all values
# plot_es_changes(plt, filter_type = "all")
```

######################################################################################




# Violins


```{r fig.height=8, fig.width=10, warning=FALSE}
# 1. Define desired facet order

# 3. Reorder countries based on dir_ch_2 (descending)
df <- df %>%
  mutate(ee_r264_name = reorder(ee_r264_name, -dir_ch_2))
df. <- df %>% filter(service != "GDP") %>% filter(service != "Pop_sqkm")
# 4. Create plot
p <- ggplot(df., aes(x = ee_r264_name, y = pct_ch_trans, fill = ee_r264_name)) +
  geom_violin(trim = FALSE, scale = "width") +
  facet_wrap(~ service, scales = "free_y") +
  scale_fill_viridis_d(option = "D") +
  labs(
    title = "Pseudo-log Scaled % Change by Service ",
    x = NULL,
    y = "Transformed % Change"
  ) +
  theme_minimal() +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1, size = 8),
    strip.text = element_text(face = "bold"),
    legend.position = "none"
  )
# 4. Create plot
p2 <- ggplot(df, aes(x = ee_r264_name, y = pct_ch, fill = ee_r264_name)) +
  geom_violin(trim = FALSE, scale = "width") +
  facet_wrap(~ service, scales = "free_y") +
  scale_fill_viridis_d(option = "D") +
  labs(
    title = "% Change by Service ",
    x = NULL,
    y = "Transformed % Change"
  ) +
  theme_minimal() +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1, size = 8),
    strip.text = element_text(face = "bold"),
    legend.position = "none"
  )
p
p2

```

#######################

## 5. Here, add plots with the differences 

```{r eval=FALSE, fig.height=8, fig.width=14, include=FALSE}
print(col)
print(names(df))
stopifnot(col %in% names(df))

col <- "HYBAS_ID"
# Top/bottom 10 countries per service
plot_es_changes(df, label_col = col, filter_type = "top_bottom", filter_val = 10)

# Top/bottom 5% per service
plot_es_changes(df, label_col = col, filter_type = "quantile", filter_val = 0.1)

# Show all values
#plot_es_changes(plt, filter_type = "all")
```


## Scatterplots

```{r}


# List of LC metrics to analyze
lc_metrics <- c("Gain_2", "Persistence_2", "Loss_2", "dir_ch_2")

# Loop over each LC metric and generate a faceted scatterplot
for (metric in lc_metrics) {
  p <- plt %>%
    ggplot(aes_string(x = metric, y = "pct_ch", color = "color")) +
    geom_point(alpha = 0.5, size = 1.2) +
    facet_wrap(~ service, scales = "free") +
    scale_color_identity() +
    labs(
      title = paste("Relationship Between", metric, "and ES % Change"),
      x = metric,
      y = "% Change in Ecosystem Service"
    ) +
    theme_minimal() +
    theme(
      strip.text = element_text(face = "bold"),
      plot.title = element_text(hjust = 0.5),
      axis.text = element_text(size = 9)
    )

  print(p)
}
```


# Scatterplots change 2

```{r, fig.height=8, fig.width=14}


# LC metrics of interest
lc_metrics <- c("Gain_2", "Persistence_2", "Loss_2", "dir_ch_2")

# Step 1: Remove top 2% outliers for each service
filtered_plt <- plt %>%
  group_by(service) %>%
  mutate(threshold = quantile(pct_ch, 0.98, na.rm = TRUE)) %>%
  ungroup() %>%
  filter(pct_ch <= threshold)

# # Step 2: Apply pseudo-log transformation
# filtered_plt <- filtered_plt %>%
#   mutate(pct_ch_log = sign(pct_ch) * log1p(abs(pct_ch)))

# Step 3: Loop through each LC metric and create faceted plots
for (metric in lc_metrics) {
  p <- ggplot(filtered_plt, aes_string(x = metric, y = "pct_ch", color = "color")) +
    geom_point(alpha = 0.5, size = 1.2) +
    facet_wrap(~ service, scales = "free") +
    scale_color_identity() +
    labs(
      title = paste("Log-Transformed % Change vs", metric),
      x = metric,
      y = "Log(% Change in ES)"
    ) +
    theme_minimal() +
    theme(
      strip.text = element_text(face = "bold"),
      plot.title = element_text(hjust = 0.5),
      axis.text = element_text(size = 9)
    )

  print(p)
}
```

```{r, fig.height=8, fig.width=14}
# library(dplyr)
# library(ggplot2)
# 
# plt <- as_tibble(read.csv(here('output_data', "metrics_change_hb_lev_6.csv")))
# plt[1] <- NULL 
# # apply filter (5 or 2%) # Remove the smalles basins. That help. Also, it seems that some biomes are more prone to artifacts than others!!!
# area_threshold <- quantile(plt$SUB_AREA, probs = 0.05, na.rm = TRUE)
# # Filter the dataset
# df <- plt %>% filter(SUB_AREA > area_threshold)
# 
# 
# t_5 <- ggplot(df, aes(x = service, y = pct_ch, fill = color)) +
#   geom_boxplot() +  # or geom_violin()
#   scale_fill_identity() +
#   facet_wrap(~ service, scales = "free_y") +
#   labs(
#     title = "Distribution of % Change by Service (Excl. Smallest 5% of Basins)",
#     x = NULL,
#     y = "Percentage Change"
#   ) +
#   theme_minimal() +
#   theme(
#     axis.text.x = element_blank(),
#     strip.text = element_text(face = "bold"),
#     legend.position = "none"
#   )
# 
# library(ggplot2)
# library(dplyr)
# 
# # Custom pseudo-log transformation
# pseudo_log <- function(x) sign(x) * log1p(abs(x))
# 
# # Apply to the filtered dataframe
# df <- plt %>% 
#   mutate(pct_ch_trans = pseudo_log(pct_ch))
# 
# # Plot with transformed values
# p <- ggplot(df, aes(x = service, y = pct_ch_trans, fill = color)) +
#   geom_violin(trim = FALSE, scale = "width") +
#   scale_fill_identity() +
#   facet_wrap(~ service, scales = "free_y") +
#   labs(
#     title = "Pseudo-log Scaled % Change by Service",
#     x = NULL,
#     y = "Transformed % Change"
#   ) +
#   theme_minimal() +
#   theme(
#     axis.text.x = element_blank(),
#     strip.text = element_text(face = "bold"),
#     legend.position = "none"
#   )
# p
```

```{r leaflet 2}

# Load libraries
# Load libraries
library(sf)
library(dplyr)
library(tidyr)
library(leaflet)
library(RColorBrewer)
library(htmltools)

# Create separate boolean columns for each service being a hotspot
for (svc in services) {
  spring_ES[[paste0("is_", svc, "_hotspot")]] <- grepl(svc, spring_ES$hotspot_services)
}
# ---------------------------------------------
# Step 1. Define services to include in the map
# ---------------------------------------------
services <- c(
  "sed_export_pct_ch", "Usle_pct_ch", "Sed_retention_ratio_pct_ch",
  "Coastal_Protection_pct_ch", "Pollination_pct_ch", "N_export_pct_ch_2020_1992_sqkm"
)

# ---------------------------------------------
# Step 2. Fix malformed hotspot_services column
# ---------------------------------------------
# Final safe parser for all cases
parse_hotspot_services <- function(x) {
  if (is.null(x) || all(is.na(x))) return(NA_character_)
  if (is.character(x) && length(x) > 1) return(x)
  cleaned <- gsub("^c\\(|\\)$", "", x)                # remove c(...) wrapper
  cleaned <- gsub('[\\"\\\']', "", cleaned)           # remove quotes
  cleaned <- trimws(cleaned)
  strsplit(cleaned, ",\\s*")[[1]]
}

spring_ES_fixed <- spring_ES %>%
  mutate(hotspot_services = lapply(hotspot_services, parse_hotspot_services))

# ---------------------------------------------
# Step 3. Pivot to long format and filter to real hotspots
# ---------------------------------------------
spring_hotspots_long <- spring_ES_fixed %>%
  select(HYBAS_ID, geom, all_of(services), hotspot_services) %>%
  pivot_longer(cols = all_of(services), names_to = "service", values_to = "value") %>%
  mutate(
    is_hotspot = mapply(function(svc, hs) {
      if (is.null(hs) || all(is.na(hs))) return(FALSE)
      svc %in% hs
    }, service, hotspot_services),
    label = paste("HYBAS:", HYBAS_ID, "<br>Service:", service, "<br>Change:", round(value, 2))
  ) %>%
  filter(is_hotspot & !is.na(value)) %>%
  st_as_sf() %>%
  st_make_valid() %>%
  st_transform(4326)

# ---------------------------------------------
# Step 4. Define color palette (diverging red-blue)
# ---------------------------------------------
pal <- colorNumeric(
  palette = "RdBu",
  domain = spring_hotspots_long$value,
  reverse = TRUE
)

# ---------------------------------------------
# Step 5. Initialize leaflet map with base layers
# ---------------------------------------------
m <- leaflet(options = leafletOptions(preferCanvas = TRUE)) %>%
  addProviderTiles("OpenStreetMap.Mapnik", group = "OSM") %>%
  addProviderTiles("CartoDB.Positron", group = "Positron") %>%
  addProviderTiles("Esri.WorldImagery", group = "Satellite")

# ---------------------------------------------
# Step 6. Add a service-specific overlay per layer
# ---------------------------------------------
for (svc in unique(spring_hotspots_long$service)) {
  layer_data <- filter(spring_hotspots_long, service == svc)
  m <- m %>% addPolygons(
    data = layer_data,
    fillColor = ~pal(value),
    fillOpacity = 0.7,
    color = "black", weight = 0.3,
    label = ~lapply(label, HTML),
    group = svc
  )
}

# ---------------------------------------------
# Step 7. Add layer control and legend
# ---------------------------------------------
m <- m %>%
  addLayersControl(
    baseGroups = c("OSM", "Positron", "Satellite"),
    overlayGroups = unique(spring_hotspots_long$service),
    options = layersControlOptions(collapsed = FALSE)
  ) %>%
  addLegend(
    "bottomright",
    pal = pal,
    values = spring_hotspots_long$value,
    title = "% Change"
  )

# ---------------------------------------------
# Step 8. Render the map
# ---------------------------------------------
m

```

```{r leaflet 2}

# Load libraries
# Load libraries
library(sf)
library(dplyr)
library(tidyr)
library(leaflet)
library(RColorBrewer)
library(htmltools)

# Create separate boolean columns for each service being a hotspot
for (svc in services) {
  spring_ES[[paste0("is_", svc, "_hotspot")]] <- grepl(svc, spring_ES$hotspot_services)
}
# ---------------------------------------------
# Step 1. Define services to include in the map
# ---------------------------------------------
services <- c(
  "sed_export_pct_ch", "Usle_pct_ch", "Sed_retention_ratio_pct_ch",
  "Coastal_Protection_pct_ch", "Pollination_pct_ch", "N_export_pct_ch_2020_1992_sqkm"
)

# ---------------------------------------------
# Step 2. Fix malformed hotspot_services column
# ---------------------------------------------
# Final safe parser for all cases
parse_hotspot_services <- function(x) {
  if (is.null(x) || all(is.na(x))) return(NA_character_)
  if (is.character(x) && length(x) > 1) return(x)
  cleaned <- gsub("^c\\(|\\)$", "", x)                # remove c(...) wrapper
  cleaned <- gsub('[\\"\\\']', "", cleaned)           # remove quotes
  cleaned <- trimws(cleaned)
  strsplit(cleaned, ",\\s*")[[1]]
}

spring_ES_fixed <- spring_ES %>%
  mutate(hotspot_services = lapply(hotspot_services, parse_hotspot_services))

# ---------------------------------------------
# Step 3. Pivot to long format and filter to real hotspots
# ---------------------------------------------
spring_hotspots_long <- spring_ES %>%
  select(HYBAS_ID, geom, all_of(services)) %>%
  pivot_longer(cols = all_of(services), names_to = "service", values_to = "value") %>%
  filter(!is.na(value)) %>%
  mutate(
    label = paste("HYBAS:", HYBAS_ID, "<br>Service:", service, "<br>Change:", round(value, 2))
  ) %>%
  st_as_sf() %>%
  st_make_valid() %>%
  st_transform(4326)

# ---------------------------------------------
# Step 4. Define color palette (diverging red-blue)
# ---------------------------------------------
pal <- colorNumeric(
  palette = "RdBu",
  domain = spring_hotspots_long$value,
  reverse = TRUE
)

m <- leaflet(options = leafletOptions(preferCanvas = TRUE)) %>%
  addProviderTiles("OpenStreetMap.Mapnik", group = "OSM") %>%
  addProviderTiles("CartoDB.Positron", group = "Positron") %>%
  addProviderTiles("Esri.WorldImagery", group = "Satellite")

for (svc in unique(spring_hotspots_long$service)) {
  layer_data <- filter(spring_hotspots_long, service == svc)
  m <- m %>% addPolygons(
    data = layer_data,
    fillColor = ~pal(value),
    fillOpacity = 0.7,
    color = "black", weight = 0.3,
    label = ~lapply(label, HTML),
    group = svc
  )
}

m <- m %>%
  addLayersControl(
    baseGroups = c("OSM", "Positron", "Satellite"),
    overlayGroups = unique(spring_hotspots_long$service),
    options = layersControlOptions(collapsed = FALSE)
  ) %>%
  addLegend(
    "bottomright",
    pal = pal,
    values = spring_hotspots_long$value,
    title = "% Change"
  )

m

```

```{r leaflet 3}
# Create separate boolean columns for each service being a hotspot
for (svc in services) {
  spring_ES[[paste0("is_", svc, "_hotspot")]] <- grepl(svc, spring_ES$hotspot_services)
}
spring_hotspots_long <- spring_ES %>%
  select(HYBAS_ID, geom, all_of(services), starts_with("is_")) %>%
  pivot_longer(cols = all_of(services), names_to = "service", values_to = "value") %>%
  mutate(
    hotspot_flag = case_when(
      service == "sed_export_pct_ch" ~ is_sed_export_pct_ch_hotspot,
      service == "Usle_pct_ch" ~ is_Usle_pct_ch_hotspot,
      service == "Sed_retention_ratio_pct_ch" ~ is_Sed_retention_ratio_pct_ch_hotspot,
      service == "Coastal_Protection_pct_ch" ~ is_Coastal_Protection_pct_ch_hotspot,
      service == "Pollination_pct_ch" ~ is_Pollination_pct_ch_hotspot,
      service == "N_export_pct_ch_2020_1992_sqkm" ~ is_N_export_pct_ch_2020_1992_sqkm_hotspot,
      TRUE ~ FALSE
    ),
    label = paste("HYBAS:", HYBAS_ID, "<br>Service:", service, "<br>Change:", round(value, 2))
  ) %>%
  filter(hotspot_flag & !is.na(value)) %>%
  st_as_sf() %>%
  st_make_valid() %>%
  st_transform(4326)
pal <- colorNumeric(
  palette = "RdBu",
  domain = spring_hotspots_long$value,
  reverse = TRUE
)

m <- leaflet(options = leafletOptions(preferCanvas = TRUE)) %>%
  addProviderTiles("OpenStreetMap.Mapnik", group = "OSM") %>%
  addProviderTiles("CartoDB.Positron", group = "Positron") %>%
  addProviderTiles("Esri.WorldImagery", group = "Satellite")

for (svc in unique(spring_hotspots_long$service)) {
  layer_data <- filter(spring_hotspots_long, service == svc)
  m <- m %>% addPolygons(
    data = layer_data,
    fillColor = ~pal(value),
    fillOpacity = 0.7,
    color = "black", weight = 0.3,
    label = ~lapply(label, HTML),
    group = svc
  )
}

m <- m %>%
  addLayersControl(
    baseGroups = c("OSM", "Positron", "Satellite"),
    overlayGroups = unique(spring_hotspots_long$service),
    options = layersControlOptions(collapsed = FALSE)
  ) %>%
  addLegend(
    "bottomright",
    pal = pal,
    values = spring_hotspots_long$value,
    title = "% Change"
  )

m
```

```{r fig.height=8, fig.width=10, warning=FALSE}
library(dplyr)
library(ggplot2)
library(forcats)

# 1. Filter the dataframe for top and bottom 10 by dir_ch_2
df_top_bottom <- df %>%
  arrange(desc(dir_ch_2)) %>%
  slice_head(n = 10) %>%
  bind_rows(
    df %>%
      arrange(dir_ch_2) %>%
      slice_head(n = 10)
  )

# 2. Reorder countries inside the filtered data
df_top_bottom <- df_top_bottom %>%
  mutate(ee_r264_name = fct_reorder(ee_r264_name, -dir_ch_2))
df_top_bottom <- df_top_bottom %>% filter(service != "GDP") %>% filter(service != "Pop_sqkm")

# 3. Create plot (pseudo-log scale)
p <- ggplot(df_top_bottom, aes(x = ee_r264_name, y = pct_ch_trans, fill = service)) +
  geom_violin(trim = FALSE, scale = "width") +
  facet_wrap(~ service, scales = "free_y") +
  scale_fill_viridis_d(option = "D") +
  labs(
    title = "Pseudo-log Scaled % Change by Service (Top and Bottom 10 Countries)",
    x = NULL,
    y = "Transformed % Change"
  ) +
  theme_minimal() +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1, size = 8),
    strip.text = element_text(face = "bold"),
    legend.position = "right"
  )

# 4. (Optional) Plot regular % change
p2 <- ggplot(df_top_bottom, aes(x = ee_r264_name, y = pct_ch, fill = service)) +
  geom_violin(trim = FALSE, scale = "width") +
  facet_wrap(~ service, scales = "free_y") +
  scale_fill_viridis_d(option = "D") +
  labs(
    title = "% Change by Service (Top and Bottom 10 Countries)",
    x = NULL,
    y = "% Change"
  ) +
  theme_minimal() +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1, size = 8),
    strip.text = element_text(face = "bold"),
    legend.position = "right"
  )

# 5. Print
p
# p2  # if you also want the regular % plot

```




