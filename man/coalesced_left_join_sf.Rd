% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/coal_l_join.R
\name{coalesced_left_join_sf}
\alias{coalesced_left_join_sf}
\title{Coalesced left join that preserves (or drops) sf geometry}
\usage{
coalesced_left_join_sf(
  x,
  y,
  by,
  prefer = c("coalesce", "x", "y", "error"),
  suffix = c("", ".y"),
  require_unique_y = FALSE,
  output = c("sf", "tibble")
)
}
\arguments{
\item{x}{An \code{sf} object (recommended) or a tibble/data.frame. If
\code{output = "sf"}, \code{x} \strong{must} be an \code{sf}.}

\item{y}{An \code{sf} object or a tibble/data.frame to join into \code{x}.
If \code{y} is \code{sf}, its geometry is dropped before joining.}

\item{by}{Join keys passed to \code{\link[dplyr:mutate-joins]{dplyr::left_join()}} (\code{character} vector or
named vector). Keys present in both inputs are kept once (dplyr’s default).}

\item{prefer}{How to resolve overlapping \strong{non-key} columns that exist in
both \code{x} and \code{y}:
\itemize{
\item \code{"coalesce"}: take \code{x} where not \code{NA}, otherwise \code{y} (default).
\item \code{"x"}: keep \code{x} values (ignore \code{y}).
\item \code{"y"}: take \code{y} where not \code{NA}, otherwise \code{x}.
\item \code{"error"}: error if any non-missing conflicts remain.
}}

\item{suffix}{Length-2 character vector of suffixes passed to
\code{\link[dplyr:mutate-joins]{dplyr::left_join()}}. The second element (e.g., \code{".y"}) is used to find
and drop the duplicate columns after resolving conflicts.}

\item{require_unique_y}{Logical; if \code{TRUE}, error if \code{y} has multiple rows
per key in \code{by}. If \code{FALSE} (default), the join is allowed to duplicate
rows of \code{x}.}

\item{output}{\code{"sf"} (default) to return an \code{sf} with \code{x}'s geometry
preserved, or \code{"tibble"} to return a plain tibble with no geometry.}
}
\value{
An object of class specified by \code{output}:
\itemize{
\item \code{"sf"}: an \code{sf} with \code{x}'s CRS and geometry, possibly with duplicated
rows if \code{y} is one-to-many on the keys.
\item \code{"tibble"}: a tibble/data.frame (no geometry column).
}
}
\description{
A convenience wrapper around \code{\link[dplyr:mutate-joins]{dplyr::left_join()}} for joining an \code{sf}
object (\code{x}) with an \code{sf} or data frame (\code{y}) while keeping exactly \strong{one}
copy of overlapping \strong{non-key} columns. Overlaps are resolved via
\code{prefer = c("coalesce","x","y","error")}. Geometry from \code{x} is preserved
(and replicated for duplicated rows) when \code{output = "sf"}.
}
\details{
\itemize{
\item Overlapping \strong{non-key} columns are detected after the join using the
\code{suffix[2]} naming (e.g., \code{col.y}). They’re resolved per \code{prefer} and
the suffixed copies are dropped.
\item Type compatibility: \code{coalesce()} requires compatible types. Cast
beforehand if needed (e.g., \code{mutate(across(col, as.numeric))}).
\item If you need a \strong{spatial} join (e.g., intersects/within), use
\code{\link[sf:st_join]{sf::st_join()}} and apply a similar coalescing pattern afterward.
}
}
\examples{
\dontrun{
library(sf); library(dplyr)
pts <- st_as_sf(data.frame(id = 1:3, x = c(0,1,2), y = c(0,1,1)),
                coords = c("x","y"), crs = 4326)
attrs <- tibble::tibble(id = c(1,2,2,3),
                        name = c("a","b","b2","c"),
                        score = c(NA, 10, 12, 20))

# Keep geometry; resolve overlaps by coalescing (x then y)
res_sf <- coalesced_left_join_sf(pts, attrs, by = "id", prefer = "coalesce", output = "sf")

# Return a plain tibble (no geometry)
res_tbl <- coalesced_left_join_sf(pts, attrs, by = "id", prefer = "y", output = "tibble")
}

}
\seealso{
\code{\link[dplyr:mutate-joins]{dplyr::left_join()}}, \code{\link[sf:st_join]{sf::st_join()}}, \code{\link[sf:st_geometry]{sf::st_drop_geometry()}}
}
