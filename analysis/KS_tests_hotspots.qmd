---
title: "KS tests: hotspots vs non-hotspots"
subtitle: "v1.0.1"
author: "Jerónimo Rodríguez Escobar"
analysis_version: "v1.0.1"
date: last-modified
date-format: "YYYY-MM-DD HH:mm zzz"
format:
#  html:
#    toc: true
#    number-sections: true
#    code-fold: false
#    toc-title: "Contents"
#    theme: cosmo
  pdf:
    toc: true
    number-sections: true
    geometry: margin=1in
    df-print: kable
editor: source
execute:
  freeze: auto
---

## Overview

Uses the hotspot definition from the extraction report to compare hotspots vs non-hotspots across socio-environmental covariates. Workflow: load helpers and cached `plt_long`, derive hotspot/complement subsets with the same thresholds, run KS tests per service × variable, and export heatmaps/bars/ECDFs to `outputs/plots/ks/` (mirrored in `outputs/plots/latest/ks/`). The goal is a quick, reproducible readout of which covariates most strongly distinguish hotspot cells.

## Interpreting the KS Results

::: callout-note
**How to read the KS analysis outputs**

- The Kolmogorov-Smirnov (KS) test compares the distribution of each covariate (e.g., population, built area, GDP, HDI) between hotspot and non-hotspot grid cells, for each ecosystem service.
- The KS statistic ($D$) measures the maximum difference between the two distributions. Higher $D$ means a stronger distinction.
- The p-value indicates whether the difference is statistically significant (after adjustment for multiple testing).
- The heatmap and barplots show which variables and services most strongly distinguish hotspots.
:::

### Key Findings

- **Strongest discriminators:** Variables like built area (GHS_BUILT_S_E2020_mean), population (GHS_POP_E2020_GLOBE_sum, GlobPOP_Count_30arc_2020_sum), and GDP (rast_gdpTot_1990_2020_30arcsec_2020_sum) consistently show high KS statistics across several services, indicating that hotspots are associated with distinct socio-environmental profiles.
- **Service patterns:** Services such as C_Risk, C_Risk_Red_Ratio, and Nature_Access tend to have higher $D$ values for built area and population, suggesting these hotspots are more urbanized or densely populated.
- **Significance:** Most top results have extremely low p-values, confirming that the observed differences are robust and unlikely due to chance.
- **Directionality:** The mean and median values for hotspots vs non-hotspots (see CSV) help interpret whether hotspots are higher or lower in each covariate. For example, if mean_hot > mean_non for population, hotspots are more populated.

### How to use these results

- **Targeting interventions:** Focus on covariates and services with the highest $D$ and lowest p-values—these are the most distinctive and may guide prioritization.
- **External validation:** The full KS results table (CSV) and plots can be shared for review, and the underlying data (plt_long) is available for reproducibility and further analysis in R, Python, or other tools.
- **Limitations:** KS tests are sensitive to distribution shape, not just mean differences. Always consider the context and possible confounders.

::: callout-note
**Exporting KS results for review and further interpretation**

The full KS results are saved as a CSV in the processed data directory (typically `/home/jeronimo/data/global_ncp/processed/ks_results_hot_vs_non.csv`). You can share this file for external review, meta-analysis, or further interpretation in any statistical software.

- **For R users:**
  ```r
  source("R/config.R") # to load cfg object
  ks_res <- read.csv(file.path(cfg$paths$processed_data_dir, "ks_results_hot_vs_non.csv"))
  ```
- **For Python users:**
  ```python
  import pandas as pd
  # Note: You may need to define the path manually if not running in an R-integrated environment
  processed_data_dir = "/home/jeronimo/data/global_ncp/processed"
  ks_res = pd.read_csv(f'{processed_data_dir}/ks_results_hot_vs_non.csv')
  ```
:::
## Setup

Uses the same wiring as the hotspot extraction report: load project helpers, set a stable root, and keep output paths under `outputs/`.

```{r}
#| label: setup
#| message: false
#| warning: false
#| echo: false

library(dplyr)
library(tidyr)
library(purrr)
library(stringr)
library(forcats)
library(ggplot2)
library(readr)
library(scales)
library(sf)
library(here)

library(devtools)   # load package helpers in /R

knitr::opts_knit$set(root.dir = here::here())
source(here::here("R","paths.R"))
devtools::load_all(quiet = TRUE)

options(dplyr.summarise.inform = FALSE)
Sys.setenv(GDAL_NUM_THREADS = "ALL_CPUS", PROJ_NETWORK = "ON")
set.seed(1)
```

## Config

Central switches to adjust  thresholds, services, variables, sampling, and output locations. This mirrors the hotspot extraction config (loss/gain/combos) so KS uses the same hotspot definition.

```{r}
#| label: config
#| echo: true

`%||%` <- function(x, y) if (is.null(x)) y else x

KS_CFG <- list(
  # hotspot definition (keep in sync with hotspot_extraction.qmd)
  pct_cutoff     = 0.05,
  threshold_mode = "percent",
  rule_mode      = "vectors",
  loss_services  = c("Nature_Access","Pollination","N_Ret_Ratio","Sed_Ret_Ratio","C_Risk_Red_Ratio"),
  gain_services  = c("Sed_export","N_export","C_Risk"),
  combos = list(
    deg_combo = c("Nature_Access","Pollination","N_export","Sed_export","C_Risk"),
    rec_combo = c("Nature_Access","Pollination","N_Ret_Ratio","Sed_Ret_Ratio","C_Risk_Red_Ratio")
  ),
  include_services = c(
    "C_Risk","N_export","Sed_export",
    "C_Risk_Red_Ratio","N_Ret_Ratio","Sed_Ret_Ratio",
    "Pollination","Nature_Access"
  ),
  # KS settings
  vars_to_test = c(
    "rast_gdpTot_1990_2020_30arcsec_2020_sum",
    "GHS_POP_E2020_GLOBE_sum",
    "GlobPOP_Count_30arc_2020_sum",
    "GHS_BUILT_S_E2020_mean",
    "fields_mehrabi_2017_mean",
    "hdi_raster_predictions_2020_mean",
    "rast_adm1_gini_disp_2020_mean"
  ),
  sampling          = "match_hot",  # none | match_hot | cap_nonhot
  comparison_mode   = "median",     # "random" (all non-hotspots) | "median" (middle 5% of change)
  nonhot_cap        = 100000L,
  permute_n         = 0,            # set >0 for permutation p
  compute_one_sided = TRUE,
  adjust_method     = "BH",
  # ECDF / plotting switches
  # Note: Log transformation is used for visualization (ECDFs) of highly skewed variables (GDP, Pop).
  # It does NOT affect the KS test statistic (D) or p-value, as KS is rank-based (invariant to monotonic transformations).
  transform_default = "auto",
  transform_by_var = c(
    "rast_gdpTot_1990_2020_30arcsec_2020_sum" = "log1p",
    "GHS_POP_E2020_GLOBE_sum"                 = "log1p",
    "GlobPOP_Count_30arc_2020_sum"            = "log1p"
  ),
  ecdf_top_k              = 8,
  ecdf_service_selection  = "top_k",  # top_k | all | custom
  mountain_service        = "Pollination",
  mountain_var            = "rast_gdpTot_1990_2020_30arcsec_2020_sum",
  mountain_transform      = "log1p",
  # outputs
  out_table  = file.path(cfg$paths$processed_data_dir, "ks_results_hot_vs_non.csv"),
  out_dir    = out_plots("ks"),
  latest_dir = out_plots("latest","ks"),
  service_suffix_pattern = "_(mean|sum)$"
)
```

## Pivot to long (cached)

Build `plt_long` from the processed grid, harmonizing service labels and keeping the socio variables we test. Cached so future renders skip the heavy pivot.

```{r}
#| label: pivot
#| eval: true
#| include: false
#| echo: false
#| results: hide
#| cache: false

rds_path <- file.path(cfg$paths$processed_data_dir, "plt_long.rds")
need_reload <- TRUE
if (file.exists(rds_path)) {
  plt_long <- readRDS(rds_path)
  if (all(KS_CFG$vars_to_test %in% names(plt_long)) && "N_export" %in% unique(plt_long$service)) need_reload <- FALSE
}

if (need_reload) {
  # Use full QA dataset to ensure socioeconomic variables are present
  gpkg <- file.path(data_dir(), "processed", "10k_grid_ES_change_benef.gpkg")
  if (!file.exists(gpkg)) {
    gpkg <- file.path(data_dir(), "processed", "10k_change_calc.gpkg")
  }
  stopifnot(file.exists(gpkg))

  lyrs <- sf::st_layers(gpkg)$name
  sf_f <- sf::st_read(gpkg, layer = lyrs[1], quiet = TRUE)
  if (!"fid" %in% names(sf_f)) sf_f$fid <- seq_len(nrow(sf_f))
  if (!"c_fid" %in% names(sf_f)) {
    if ("c_fid.x" %in% names(sf_f)) sf_f <- dplyr::rename(sf_f, c_fid = c_fid.x)
    else if ("c_fid.y" %in% names(sf_f)) sf_f <- dplyr::rename(sf_f, c_fid = c_fid.y)
    else if ("id" %in% names(sf_f))      sf_f <- dplyr::rename(sf_f, c_fid = id)
  }
  sf_f <- dplyr::select(sf_f, -dplyr::any_of(c("c_fid.x","c_fid.y")))
  plt <- sf::st_drop_geometry(sf_f)

  if ("continent" %in% names(plt)) {
    plt <- dplyr::filter(plt, !continent %in% c("Antarctica", "Seven seas (Open Ocean)"))
  }

  chg_cols <- grep("_(abs|pct)_chg$", names(plt), value = TRUE)
  socio_vars <- setdiff(names(plt), c("fid","c_fid", chg_cols))

  # Optimization: Deduplicate columns mapping to the same service before pivoting
  # This prevents exploding the dataframe size and avoids expensive group_by/slice later
  matches <- stringr::str_match(chg_cols, "^(.*)_(abs|pct)_chg$")
  col_map <- tibble::tibble(
    col  = chg_cols,
    base = matches[,2],
    type = matches[,3]
  ) |>
    dplyr::mutate(service_norm = stringr::str_remove(base, KS_CFG$service_suffix_pattern)) |>
    dplyr::group_by(service_norm, type) |>
    dplyr::slice(1) |>
    dplyr::ungroup()

  cols_to_pivot <- col_map$col

  plt_long <- plt |>
    tidyr::pivot_longer(
      cols = tidyselect::all_of(cols_to_pivot),
      names_to = c("service", "chg_type"),
      names_pattern = "^(.*)_(abs|pct)_chg$",
      values_to = "chg_value"
    ) |>
    dplyr::mutate(service = stringr::str_remove(service, KS_CFG$service_suffix_pattern)) |>
    tidyr::pivot_wider(
      names_from  = chg_type,
      values_from = chg_value,
      names_vary  = "slowest"
    ) |>
    dplyr::rename(abs_chg = abs, pct_chg = pct) |>
    dplyr::select(fid, c_fid, service, abs_chg, pct_chg, dplyr::any_of(socio_vars)) |>
    dplyr::filter(!is.na(c_fid)) |>
    dplyr::filter(!(is.infinite(abs_chg) | is.infinite(pct_chg))) |>
    dplyr::filter(!is.na(abs_chg) | !is.na(pct_chg))

  # Canonical lookup matching hotspot_extraction.qmd (v1.0.1)
  canonical_lookup <- c(
    sed_export       = "Sed_export",
    n_export         = "N_export",
    n_retention      = "N_retention",
    nature_access    = "Nature_Access",
    pollination      = "Pollination",
    usle             = "USLE",
    n_ret_ratio      = "N_Ret_Ratio",
    sed_ret_ratio    = "Sed_Ret_Ratio",
    coastal_protection_rt            = "C_Risk",
    coastal_protection_rt_nohab_all  = "C_Risk_NoHab",
    coastal_protection_rt_ratio      = "C_Risk_Red_Ratio",
    rt_ratio         = "C_Risk_Red_Ratio",
    rt               = "C_Risk",
    c_risk           = "C_Risk",
    c_risk_red_ratio = "C_Risk_Red_Ratio",
    rt_service       = "C_Prot_service",
    rt_nohab         = "Rt_nohab"
  )
  plt_long <- plt_long |>
    dplyr::mutate(service = tolower(service)) |>
    dplyr::mutate(service = dplyr::recode(service, !!!canonical_lookup))

  saveRDS(plt_long, rds_path)
}

svc_order <- c(
  "C_Risk","N_export","Sed_export",
  "C_Risk_Red_Ratio","N_Ret_Ratio","Sed_Ret_Ratio",
  "Pollination","Nature_Access"
)
extras <- setdiff(unique(plt_long$service), svc_order)
plt_long <- plt_long |>
  dplyr::mutate(service = factor(service, levels = c(svc_order, sort(extras))))
```

## Derive hotspots (hotspot vs complement)

Apply the hotspot definition to `plt_long` to get `hotspots_df` and `non_hotspots_df`. This uses the same loss/gain vectors and cutoff as the hotspot extraction report.

```{r}
#| label: build-hotspots
#| message: false
#| warning: false
#| eval: true
#| echo: false

svc_keep <- KS_CFG$include_services %||% levels(plt_long$service) %||% unique(plt_long$service)
hs <- extract_hotspots(
  df            = dplyr::filter(plt_long, service %in% svc_keep),
  value_col     = "pct_chg",
  pct_cutoff    = KS_CFG$pct_cutoff,
  threshold_mode= KS_CFG$threshold_mode,
  rule_mode     = KS_CFG$rule_mode,
  loss_services = KS_CFG$loss_services,
  gain_services = KS_CFG$gain_services,
  combos        = KS_CFG$combos,
  id_cols       = c("c_fid")
)

hotspots_df <- hs$hotspots_df
inverse_df  <- hs$non_hotspots_df

stopifnot(nrow(hotspots_df) > 0, nrow(inverse_df) > 0)

# Optional: Filter non-hotspots to "Median Spots" (typical change)
# This compares hotspots specifically to "business as usual" areas,
# rather than the entire background (which includes extreme gains/losses in the other direction).
if (KS_CFG$comparison_mode == "median") {
  message("Filtering non-hotspots to the median 5% range (47.5th-52.5th percentiles) of change...")

  # Helper to filter safely per service
  filter_median_safe <- function(df, svc_name) {
    d_svc <- df[df$service == svc_name, ]
    if (nrow(d_svc) < 100) return(d_svc) # Too few to filter

    # Try narrow median
    q_lo <- stats::quantile(d_svc$pct_chg, 0.475, na.rm = TRUE)
    q_hi <- stats::quantile(d_svc$pct_chg, 0.525, na.rm = TRUE)
    d_filt <- d_svc[d_svc$pct_chg >= q_lo & d_svc$pct_chg <= q_hi, ]

    # Fallback if too aggressive (e.g. sparse data)
    if (nrow(d_filt) < 50) {
      message("  Service ", svc_name, ": Median 5% too sparse (n=", nrow(d_filt), "). Using IQR (25-75%) instead.")
      q_lo <- stats::quantile(d_svc$pct_chg, 0.25, na.rm = TRUE)
      q_hi <- stats::quantile(d_svc$pct_chg, 0.75, na.rm = TRUE)
      d_filt <- d_svc[d_svc$pct_chg >= q_lo & d_svc$pct_chg <= q_hi, ]
    }
    return(d_filt)
  }

  inverse_df <- purrr::map_dfr(unique(inverse_df$service), ~filter_median_safe(inverse_df, .x))
  message("Median spots selected. Rows: ", nrow(inverse_df))
}
```

## KS tests: hotspots vs non-hotspots

Run KS per `service × variable`, with optional downsampling of the non-hotspot pool. Results are written to `outputs/tables/ks_results_hot_vs_non.csv`.

```{r}
#| label: run-ks
#| message: false
#| warning: false

dir.create(dirname(KS_CFG$out_table), recursive = TRUE, showWarnings = FALSE)
ks_res <- run_ks_hot_vs_non(
  hotspots_df      = hotspots_df,
  inverse_df       = inverse_df,
  vars             = KS_CFG$vars_to_test,
  include_services = svc_keep,
  sampling         = KS_CFG$sampling,
  nonhot_cap       = KS_CFG$nonhot_cap,
  permute_n        = KS_CFG$permute_n,
  compute_one_sided= KS_CFG$compute_one_sided,
  adjust_method    = KS_CFG$adjust_method,
  out_csv          = KS_CFG$out_table
)

dplyr::glimpse(ks_res, width = 120)
```

## Visualizations and exports

Heatmap, per-variable bars, ECDF overlays (top-K services per variable), and an optional mountain plot. Plots are saved under `outputs/plots/ks/` and mirrored to `outputs/plots/latest/ks/` for embedding.

### KS Heatmap

This heatmap summarizes the Kolmogorov-Smirnov (KS) statistic ($D$) for all service-covariate pairs. The $D$ statistic ranges from 0 to 1 and measures the maximum distance between the cumulative distribution functions of hotspots and non-hotspots. Brighter colors indicate a larger $D$, meaning the hotspot locations are distinct from the rest of the landscape for that variable. Use this to quickly identify which socioeconomic factors are most strongly associated with hotspots of each service.

```{r}
#| label: ks-plots-heatmap
#| message: false
#| warning: false
#| echo: false

ks_plot_dir <- KS_CFG$out_dir
# Clean up previous run outputs in the main KS folder to avoid stale plots
if (dir.exists(ks_plot_dir)) {
  unlink(list.files(ks_plot_dir, full.names = TRUE), recursive = TRUE)
}
dir.create(ks_plot_dir, recursive = TRUE, showWarnings = FALSE)

# Heatmap
heat_path <- file.path(ks_plot_dir, "ks_heatmap.png")
svc_order <- c(
  "C_Risk", "C_Risk_Red_Ratio",
  "N_export", "N_Ret_Ratio",
  "Sed_export", "Sed_Ret_Ratio",
  "Pollination", "Nature_Access"
)

# Adjust color ramp: 'sqrt' transform helps visualize differences in lower D values
# when a few high values might otherwise compress the scale.
ggplot2::ggsave(
  heat_path,
  plot_ks_heatmap(
    ks_res,
    fill_limits = c(0, NA),
    reorder = FALSE
  ) +
    ggplot2::scale_x_discrete(drop = FALSE, limits = svc_order) +
    ggplot2::scale_fill_viridis_c(name = "KS Statistic (D)", option = "magma", trans = "sqrt"),
  width = 10, height = 6, dpi = 300, bg = "white"
)

# Bars by variable
bar_files <- character(0)
for (v in KS_CFG$vars_to_test) {
  safe_v <- gsub("[^A-Za-z0-9_]+", "_", v)
  p_bar <- plot_ks_bars(ks_res, v, top_k = 12)
  out <- file.path(ks_plot_dir, paste0("ks_bars_", safe_v, ".png"))
  ggplot2::ggsave(out, p_bar, width = 8, height = 6, dpi = 300, bg = "white")
  bar_files <- c(bar_files, out)
}

```

### ECDF Overlays

The Empirical Cumulative Distribution Function (ECDF) plots visualize the full distribution of covariate values for hotspots (Red) versus non-hotspots (Blue). A gap between the curves indicates a difference in distribution.

**Note on Transformations:** We use a `log1p` transformation ($\log(x+1)$) for variables with highly skewed distributions (e.g., GDP, Population) to compress the scale and make differences in the lower range visible. Variables that are already indices (e.g., HDI, GINI) are plotted on their raw scale.

```{r}
#| label: ks-plots-ecdf
#| echo: false
ks_plot_dir <- KS_CFG$out_dir
# ECDF grids
ecdf_dir <- file.path(ks_plot_dir, "ecdf")
dir.create(ecdf_dir, recursive = TRUE, showWarnings = FALSE)
ecdf_files <- save_ecdf_grids(
  hotspots_df, inverse_df,
  vars                = KS_CFG$vars_to_test,
  ks_res              = ks_res,
  service_selection   = KS_CFG$ecdf_service_selection,
  top_k               = KS_CFG$ecdf_top_k,
  transform_default   = KS_CFG$transform_default,
  transform_by_var    = KS_CFG$transform_by_var,
  out_dir             = ecdf_dir,
  prefix              = "ecdf",
  width = 10, height = 7, dpi = 300, use_ragg = FALSE,
  verbose = FALSE
)

```

### Directionality (Cliff's Delta)

The bar plots below display **Cliff's Delta**, a non-parametric effect size measure quantifying the difference between hotspot and non-hotspot distributions. Positive values (Red) indicate that the covariate is consistently **higher** in hotspots, while negative values (Blue) indicate it is **lower**. The magnitude represents the strength of the separation.

```{r}
#| label: ks-plots-direction
#| echo: false
ks_plot_dir <- KS_CFG$out_dir
# Directionality plot (Cliff's Delta)
dir_path <- file.path(ks_plot_dir, "directionality_cliffs_delta.png")
svc_order <- c(
  "C_Risk", "C_Risk_Red_Ratio",
  "N_export", "N_Ret_Ratio",
  "Sed_export", "Sed_Ret_Ratio",
  "Pollination", "Nature_Access"
)

# Clean up variable names for plotting
ks_res_plot <- ks_res %>%
  mutate(var_label = gsub("_", " ", var)) %>%
  mutate(var_label = stringr::str_wrap(var_label, 40))

# Define signed 4th root transform to further improve visibility of low values in divergent scale
signed_pow4 <- scales::trans_new(
  "signed_pow4",
  transform = function(x) sign(x) * abs(x)^0.25,
  inverse = function(x) sign(x) * abs(x)^4
)

p_direction <- ggplot(ks_res_plot, aes(x = service, y = cliffs_delta, fill = cliffs_delta)) +
  geom_bar(stat = "identity", position = "identity") +
  geom_hline(yintercept = 0, linetype = "dashed") +
  scale_fill_gradient2(low = "blue", mid = "white", high = "red", midpoint = 0, name = "Cliff's Delta", trans = signed_pow4) +
  scale_x_discrete(drop = FALSE, limits = rev(svc_order)) +
  facet_wrap(~ var_label, ncol = 2, scales = "free_y") +
  coord_flip() +
  labs(
    title = "Directionality of Hotspot Effects (Cliff's Delta)",
    subtitle = "Cliff's Delta > 0 (red) indicates hotspots have higher values of the covariate.\nCliff's Delta < 0 (blue) indicates hotspots have lower values.",
    x = "Ecosystem Service",
    y = "Cliff's Delta (Effect Size)"
  ) +
  theme_minimal(base_size = 12) +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1),
    strip.text = element_text(size = 8)
  )

ggsave(
  dir_path,
  p_direction,
  width = 14, height = 10, dpi = 300, bg = "white"
)

# Optional mountain plot
mountain_file <- NULL
# Skipped for now to avoid "Too few points" errors
# if (!is.null(KS_CFG$mountain_service) && !is.null(KS_CFG$mountain_var)) {
#   mountain_file <- file.path(
#     ks_plot_dir,
#     paste0("mountain_", gsub("[^A-Za-z0-9_]+","_", KS_CFG$mountain_service), "_",
#            gsub("[^A-Za-z0-9_]+","_", KS_CFG$mountain_var), ".png")
#   )
#   tryCatch({
#     p_mtn <- plot_ks_mountain(
#       hotspots_df, inverse_df,
#       service_id = KS_CFG$mountain_service,
#       var_id     = KS_CFG$mountain_var,
#       transform  = KS_CFG$mountain_transform
#     )
#     ggplot2::ggsave(mountain_file, p_mtn, width = 8, height = 5, dpi = 300, bg = "white")
#   }, error = function(e) {
#     message("Skipping mountain plot: ", e$message)
#   })
# }

# Mirror to outputs/plots/latest/ks for embedding
dir.create(KS_CFG$latest_dir, recursive = TRUE, showWarnings = FALSE)
# Clean up latest dir
unlink(list.files(KS_CFG$latest_dir, full.names = TRUE), recursive = TRUE)

all_pngs <- list.files(ks_plot_dir, pattern = "\\.png$", recursive = TRUE, full.names = TRUE)
all_pngs <- all_pngs[!grepl("/latest/", all_pngs)]
if (length(all_pngs)) {
  invisible(file.copy(all_pngs, KS_CFG$latest_dir, overwrite = TRUE))
}
```

## Quick looks

```{r}
#| label: ks-preview
#| echo: false
#| results: 'asis'

ks_plot_dir <- KS_CFG$out_dir
pngs <- list.files(ks_plot_dir, pattern = "\\.png$", recursive = TRUE, full.names = FALSE)
if (length(pngs)) {
  rel_dir <- file.path("..", "outputs", "plots", "ks")
  rel_paths <- file.path(rel_dir, pngs)
  md <- paste(sprintf("![](%s)", rel_paths), collapse = "\n\n")
  knitr::asis_output(md)
} else {
  knitr::asis_output("> No KS plots were generated; check upstream chunks.")
}
```
