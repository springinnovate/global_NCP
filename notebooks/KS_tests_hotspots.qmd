---
title: "Kolmogorov_Tests"
author: "Jer'onimo Rodriguez Escobar"
format: html
editor: visual
---

# 3. Run Tests

```{r ks test}

load(here("output_data", "res_hs_5.RData"))

hotspots_dg <- res$hotspots_df
inverse_df  <- res$non_hotspots_df


# check if summary sf worked (has all the values correctly identified)
hp2 <- res$summary_sf
hp2$c_fid.y <- NULL 
hp2$hotspot_services <- NULL
hp2 <- hp2 %>% filter(!is.na(hotspot_count)) # this should be INSIDE of the function, will take care of this later
hp2 <- left_join(hp2, hotspots_sf, by = 'fid')

all <- c("Nature_Access","Pollination","N_Ret_Ratio","Sed_Ret_Ratio","C_Risk_Red_Ratio","Sed_export","N_export","C_Risk")
st_write(hp2, here("output_data", "hotspots_5_final.gpkg"), append=FALSE)
inverse_df <- inverse_df %>% filter(service %in% all)
rm(res, sf_f)


# Run KS tests: hotspots vs non-hotspots per service for selected variables
run_ks_hot_vs_non <- function(
  plt_long, inverse_df,
  vars = c("rast_gdpTot_1990_2020_30arcsec_2020_sum",
           "GHS_POP_E2020_GLOBE_sum", "GlobPOP_Count_30arc_2020_sum"),
  services = NULL,
  adjust_method = "BH",
  permute_n = 0,              # >0 to compute permutation p-values
  seed = 42,
  out_csv = "output_charts/ks_results_hot_vs_non.csv"
) {
  set.seed(seed)

  # tag groups and combine
  df <- bind_rows(
    plt_long   %>% mutate(group = "hotspot"),
    inverse_df %>% mutate(group = "nonhotspot")
  )

  # subset services if provided
  if (!is.null(services)) {
    df <- df %>% filter(service %in% services)
  }

  # helper: one KS (and optional permutation) for one service/variable
  ks_one <- function(d, v, permute_n = 0) {
    x <- d %>% filter(group == "hotspot")    %>% pull(.data[[v]])
    y <- d %>% filter(group == "nonhotspot") %>% pull(.data[[v]])
    x <- as.numeric(x); y <- as.numeric(y)
    x <- x[is.finite(x)]; y <- y[is.finite(y)]
    n_hot <- length(x); n_non <- length(y)

    if (n_hot < 2 || n_non < 2) {
      return(tibble(D = NA_real_, p_value = NA_real_, p_perm = NA_real_,
                    n_hot = n_hot, n_non = n_non))
    }

    # KS (asymptotic p; ties -> approximate)
    kt <- suppressWarnings(stats::ks.test(x, y, alternative = "two.sided", exact = FALSE))
    D_obs <- as.numeric(kt$statistic)
    p_asym <- kt$p.value

    # Optional permutation p-value (label shuffle within service)
    p_perm <- NA_real_
    if (permute_n > 0) {
      z <- c(x, y)
      g <- c(rep(1L, n_hot), rep(0L, n_non))
      D_perm <- numeric(permute_n)
      for (i in seq_len(permute_n)) {
        g_shuf <- sample(g)
        D_perm[i] <- suppressWarnings(as.numeric(
          stats::ks.test(z[g_shuf == 1L], z[g_shuf == 0L], exact = FALSE)$statistic
        ))
      }
      p_perm <- mean(D_perm >= D_obs)
    }

    tibble(D = D_obs, p_value = p_asym, p_perm = p_perm,
           n_hot = n_hot, n_non = n_non)
  }

  # run per var × service
  results <- map_dfr(vars, function(v) {
    df %>%
      select(service, group, val = .data[[v]]) %>%
      filter(!is.na(val)) %>%
      group_by(service) %>%
      group_modify(~ ks_one(.x %>% mutate(!!v := val, .keep="unused"), v, permute_n)) %>%
      ungroup() %>%
      mutate(var = v, .before = 1)
  }) %>%
    group_by(var) %>%
    mutate(p_adj = p.adjust(p_value, method = adjust_method)) %>%
    ungroup() %>%
    arrange(var, service)

  # write results
  dir.create(dirname(out_csv), recursive = TRUE, showWarnings = FALSE)
  readr::write_csv(results, out_csv)
  results
}

```

```{r run KS}
vars_to_test <- c("rast_gdpTot_1990_2020_30arcsec_2020_sum",
                  "GHS_POP_E2020_GLOBE_sum","GlobPOP_Count_30arc_2020_sum", "GHS_BUILT_S_E2020_mean", "fields_mehrabi_2017_mean","hdi_raster_predictions_2020_mean", "rast_adm1_gini_disp_2020_mean" )
ks_res <- run_ks_hot_vs_non(
  plt_long, inverse_df,
  vars         = vars_to_test,
  adjust_method = "BH",
  permute_n     = 0,   # set to, say, 2000 for permutation p-values (slower)
  out_csv       = here("output_data", "ks_results_hot_vs_non.csv")
)

ks_res
```

```{r ECD overlay}

plot_ecdf_hot_vs_non <- function(plt_long, inverse_df, service_id, var) {
  dd <- bind_rows(
    plt_long   %>% mutate(group = "hotspot"),
    inverse_df %>% mutate(group = "nonhotspot")
  ) %>%
    filter(service == service_id) %>%
    transmute(group, val = as.numeric(.data[[var]])) %>%
    filter(is.finite(val))

  ggplot(dd, aes(val, color = group)) +
    stat_ecdf(size = 0.8) +
    labs(title = paste("ECDF:", service_id, "-", var),
         x = var, y = "F(value)", color = NULL) +
    theme_minimal()
}
```

```{r aubmrnt + plots}


# ----(1) Augment KS with direction: median difference + AUC (MW-based) ----
augment_ks_with_direction <- function(plt_long, inverse_df, ks_res, vars) {
  # bind groups
  base <- bind_rows(
    plt_long   %>% mutate(group = "hotspot"),
    inverse_df %>% mutate(group = "nonhotspot")
  ) %>%
    select(service, group, all_of(vars))

  # long for convenience
  long <- base %>%
    pivot_longer(cols = all_of(vars), names_to = "var", values_to = "val") %>%
    filter(is.finite(val))

  # helper: AUC = P(hotspot > nonhotspot)
  auc_one <- function(x, y) {
    # Wilcoxon W = sum of ranks of x minus n_x*(n_x+1)/2
    nx <- length(x); ny <- length(y)
    if (nx == 0 || ny == 0) return(NA_real_)
    r <- rank(c(x, y), ties.method = "average")
    W <- sum(r[seq_len(nx)]) - nx*(nx+1)/2
    AUC <- W / (nx * ny)
    as.numeric(AUC)
  }

  dir_summ <- long %>%
    group_by(service, var) %>%
    summarise(
      med_hot  = median(val[group == "hotspot"], na.rm = TRUE),
      med_non  = median(val[group == "nonhotspot"], na.rm = TRUE),
      delta_med = med_hot - med_non,
      auc = auc_one(val[group == "hotspot"], val[group == "nonhotspot"]),
      n_hot = sum(group == "hotspot"),
      n_non = sum(group == "nonhotspot"),
      .groups = "drop"
    )

  ks_res %>%
    left_join(dir_summ, by = c("service","var"))
}

# ----(2) Heatmap of D with direction arrows (↑ hotspot higher; ↓ lower) ----
plot_ks_heatmap <- function(ks_aug, title = "KS effect size (D) by service × variable") {
  # order services by mean D across variables for nicer display
  ord <- ks_aug %>%
    group_by(service) %>%
    summarise(D_mean = mean(D, na.rm = TRUE), .groups = "drop") %>%
    arrange(desc(D_mean)) %>% pull(service)

  ks_aug %>%
    mutate(service = factor(service, levels = ord),
           var = factor(var)) %>%
    ggplot(aes(service, var, fill = D)) +
    geom_tile(color = "white", linewidth = 0.15) +
    # arrow annotation (direction by median difference)
    geom_text(aes(label = ifelse(is.na(delta_med), "",
                                 ifelse(delta_med > 0, "↑", "↓"))),
              size = 3, color = "white") +
    scale_fill_viridis_c(option = "C", limits = c(0, NA), oob = squish, name = "KS D") +
    coord_fixed() +
    labs(title = title, x = "Service", y = "Variable",
         subtitle = "Arrow shows direction of median difference (hotspot vs non-hotspot)") +
    theme_minimal(base_size = 11) +
    theme(
      axis.text.x = element_text(angle = 45, hjust = 1),
      panel.grid = element_blank()
    )
}

# ----(3) Bar charts: top-K services by D per variable ---------------------
plot_ks_bars <- function(ks_aug, var_id, top_k = 10) {
  d <- ks_aug %>%
    filter(var == var_id) %>%
    arrange(desc(D)) %>%
    mutate(service = fct_reorder(service, D))
  d_top <- head(d, top_k)
  ggplot(d_top, aes(service, D, fill = D)) +
    geom_col() +
    coord_flip() +
    scale_fill_viridis_c(option = "C", guide = "none") +
    labs(title = paste0("Top ", top_k, " services by KS D — ", var_id),
         x = NULL, y = "KS D") +
    theme_minimal(base_size = 11)
}

# ----(4) ECDF overlays for top-K services per variable --------------------
plot_ecdf_grid <- function(plt_long, inverse_df, var_id, top_k = 4, transform = c("identity","log1p")[2]) {
  transform <- match.arg(transform)
  base <- bind_rows(
    plt_long   %>% mutate(group = "hotspot"),
    inverse_df %>% mutate(group = "nonhotspot")
  ) %>% select(service, group, val = all_of(var_id)) %>% filter(is.finite(val))

  # compute D to find top services (re-using ks logic quickly)
  find_D <- function(d) {
    x <- d$val[d$group=="hotspot"]; y <- d$val[d$group=="nonhotspot"]
    if (length(x) < 2 || length(y) < 2) return(NA_real_)
    suppressWarnings(as.numeric(stats::ks.test(x, y, exact = FALSE)$statistic))
  }
  top_services <- base %>% group_by(service) %>%
    summarise(D = find_D(cur_data()), .groups = "drop") %>%
    arrange(desc(D)) %>% slice_head(n = top_k) %>% pull(service)

  dd <- base %>% filter(service %in% top_services)

  # transform just for plotting
  if (transform == "log1p") dd <- dd %>% mutate(val = log1p(val))

  ggplot(dd, aes(val, color = group)) +
    stat_ecdf(size = 0.9) +
    facet_wrap(~ service, scales = "free_x") +
    labs(title = paste("ECDF overlays —", var_id, if (transform=="log1p") "(log1p scale)" else ""),
         x = var_id, y = "F(value)", color = NULL) +
    scale_color_manual(values = c("nonhotspot"="#2D708E", "hotspot"="#D43D51")) +
    theme_minimal(base_size = 11) +
    theme(legend.position = "top")
}

# ----(5) Mountain plot (CDF difference) for one service × variable --------
plot_ks_mountain <- function(plt_long, inverse_df, service_id, var_id, transform = c("identity","log1p")[2], n_grid = 512) {
  transform <- match.arg(transform)
  dd <- bind_rows(
    plt_long   %>% mutate(group = "hotspot"),
    inverse_df %>% mutate(group = "nonhotspot")
  ) %>% filter(service == service_id) %>%
    transmute(group, x = as.numeric(.data[[var_id]])) %>%
    filter(is.finite(x))
  if (transform == "log1p") dd <- dd %>% mutate(x = log1p(x))

  if (nrow(dd) < 4) stop("Too few points for mountain plot")

  rng <- range(dd$x)
  grid <- seq(rng[1], rng[2], length.out = n_grid)

  ecdf_h <- ecdf(dd$x[dd$group=="hotspot"])
  ecdf_n <- ecdf(dd$x[dd$group=="nonhotspot"])
  delta  <- ecdf_h(grid) - ecdf_n(grid)
  D      <- max(abs(delta), na.rm = TRUE)

  tib <- tibble(x = grid, delta = delta)

  ggplot(tib, aes(x, delta)) +
    geom_hline(yintercept = 0, color = "grey60") +
    geom_line(size = 0.9) +
    labs(title = paste("Mountain plot:", service_id, "—", var_id),
         subtitle = paste0("Max |Δ| = D = ", signif(D, 3),
                           "   (positive = hotspots higher CDF)"),
         x = if (transform=="log1p") paste0(var_id, " (log1p)") else var_id,
         y = expression(F[hot](x) - F[non](x))) +
    theme_minimal(base_size = 11)
}
```

```{r plot ks}

# 1) Augment KS table with direction summaries
vars_to_test <-  c("rast_gdpTot_1990_2020_30arcsec_2020_sum",
                  "GHS_POP_E2020_GLOBE_sum",
                  "GlobPOP_Count_30arc_2020_sum", 
                  "GHS_BUILT_S_E2020_mean",
                  "fields_mehrabi_2017_mean",
                  "hdi_raster_predictions_2020_mean",
                  "rast_adm1_gini_disp_2020_mean" )

ks_aug <- augment_ks_with_direction(plt_long, inverse_df, ks_res, vars_to_test)

# 2) Heatmap of D with direction arrows
p_heat <- plot_ks_heatmap(ks_aug)
ggsave(here("output_charts", "ks_heatmap.png"), p_heat, width = 10, height = 6, dpi = 300, bg = "white")

# 3) Bars by variable
dir.create("output_charts/ks", showWarnings = FALSE, recursive = TRUE)#
for (v in vars_to_test) {
  p_bar <- plot_ks_bars(ks_aug, v, top_k = 12)
  ggsave(file.path(here("output_charts"), paste0("ks_bars_", v, ".png")),
         p_bar, width = 8, height = 6, dpi = 300, bg = "white")
}

# 4) ECDF overlays for top services (log1p scale works well for GDP/pop)
p_ecdf_gdp <- plot_ecdf_grid(plt_long, inverse_df,
                             "rast_gdpTot_1990_2020_30arcsec_2020_sum",
                             top_k = 6, transform = "log1p")
ggsave(here("output_charts","ecdf_gdp.png"), p_ecdf_gdp, width = 10, height = 7, dpi = 300, bg = "white")

p_ecdf_pop <- plot_ecdf_grid(plt_long, inverse_df,
                             "GHS_POP_E2020_GLOBE_sum",
                             top_k = 6, transform = "log1p")
ggsave(here("output_charts","ecdf_pop.png"), p_ecdf_pop, width = 10, height = 7, dpi = 300, bg = "white")

# 5) Mountain plot for a specific service × variable (pick a “big D”)
p_mtn <- plot_ks_mountain(plt_long, inverse_df,
                          service_id = "Pollination",
                          var_id = "rast_gdpTot_1990_2020_30arcsec_2020_sum",
                          transform = "log1p")
ggsave(here("output_charts","mountain_pollination_gdp.png"), p_mtn, width = 8, height = 5, dpi = 300, bg = "white")
```

```{#| echo: false}
2 * 2
```

The `echo: false` option disables the printing of code (only output is displayed).
