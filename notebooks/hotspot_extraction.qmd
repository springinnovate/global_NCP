---
title: "Hotpot Extraction"
format: html
editor: visual
---

```{r setup, message=FALSE, warning=FALSE}
library(terra)
library(sf)
library(dplyr)
library(ggplot2)
library(tidyr)
library(purrr)
library(diffeR)
library(here)
library(stringr)
library(tidytext)
library(rlang)
library(readr)
library(tidyr)
library(forcats)
library(scales)
library(RColorBrewer)
library(htmltools)
library(leaflet)
library(devtools)
library(reticulate)
library(exactextractr)
library(httpgd)
library(ggnewscale)   # allows multiple fill scales
library(viridisLite)
library(ragg)
load_all()

#source the helper functions
# set venv focr Python
use_virtualenv("/home/jeronimo/venvs/coastal_snap_env", required = TRUE)
#inpath <- '/Users/rodriguez/Library/CloudStorage/OneDrive-WorldWildlifeFund,Inc/global_NCP/output_data'

```

####################### START HERE

# 1 Hotspot Extraction

## 1.1 Prepare Date for Analysis

Here, the spatial objects with the additional attributes are loaded and reformatted for analysis and chart preparation - **pivot & tidy**. Add to the documentation , environment or however that's called the vectors to select and order the columns. This should actually be done as a database structure. The columns live somewhere and are summoned upon need from a set of options (list_dir).

```{r pivot}

#| eval: true
#| include: true
 inpath <- here("output_data")
 inpath <- '/home/jeronimo/OneDrive/PROJECTS/Global_NCP/Final_outputs'
#  get pct as standalone data to add to the table
# Most recent version of synthesis data:
sf_f <- st_read(paste0(inpath, '/', '10k_grid_ES_change_benef.gpkg'))
# add fid
sf_f$fid <- seq_len(nrow(sf_f)) 
plt <- st_drop_geometry(sf_f)

# get the benef vars (all that are not "chg")
socio_vars <- names(plt)[
  names(plt) != c("fid", "c_fid") & 
  !grepl("chg$", names(plt))
]

# Pivot all columns that contain pct_ch, keeping other relevant vars

plt_long <- plt %>%
  pivot_longer(
    cols = matches("pct_chg"),
    names_to = "service",
    values_to = "pct_chg"
  ) %>%
  select(fid, c_fid, service, pct_chg, all_of(socio_vars)) %>% 
  mutate(service = str_replace(service, "_pct_chg.*", "")) %>% 
  mutate(service = str_replace(service, "_mean.*", "")) %>% 
  filter(!is.na(pct_chg)) %>% filter(!is.na(c_fid)) %>% filter(pct_chg != Inf)  # remove infinite values and those for which Country Id is NA
  
  
# rename some variables (just for aesthetics) Eventually there must be an easier way to deal with it. Most of my struggles have been about this issue. 

  plt_long <- plt_long %>% mutate(service = case_when(
   service == "sed_export" ~ "Sed_export",
   service == "n_export" ~ "N_export",
   service == "n_retention" ~ "N_retention",
   service == "nature_access" ~ "Nature_Access",
   service == "pollination" ~ "Pollination",
   service == "usle" ~ "USLE",
   service == "n_ret_ratio" ~ "N_Ret_Ratio",
   service == "sed_ret_ratio" ~ "Sed_Ret_Ratio",
   service == "Rt_ratio" ~ "C_Risk_Red_Ratio",
   service == "Rt" ~ "C_Risk",
   service == "Rt_service" ~ "C_Prot_service",
   TRUE ~ service
   ))
  
  
 
# Set service levesl one single time and for all. Don't drop some varaibles here, filter afterwards, it can be difficult/annpying to recover!!!
service_levels <- c("Nature_Access","N_export","N_retention", "N_Ret_Ratio", "Sed_export", "USLE", "Sed_Ret_Ratio", "Rt_nohab","C_Risk","C_Prot_service", "C_Risk_Red_Ratio", "Pollination") 

```

## 1.2 Get Hotspots

```{r run get hotsposts function}
loss <- c("Nature_Access","Pollination","N_Ret_Ratio","Sed_Ret_Ratio","C_Risk_Red_Ratio")
gain <- c("Sed_export","N_export","C_Risk")

res <- extract_hotspots(
  df = plt_long,
  value_col = "pct_chg",
  pct_cutoff = 0.05,
  threshold_mode = "percent",
  rule_mode = "vectors",
  loss_services = loss,
  gain_services = gain,
  combos = list(
    combo_1 = c("Nature_Access","Pollination","N_export","Sed_export","C_Risk"),
    combo_2 = c("Nature_Access","Pollination","N_Ret_Ratio","Sed_Ret_Ratio","C_Risk_Red_Ratio")
  ),
  #side = "both",
  id_cols = "c_fid",
  sf_obj = sf_f
)

hotspots_sf <- res$hotspots_sf
plt_long <- res$hotspots_df
inverse_df  <- res$non_hotspots_df

hotspots_sf <- hotspots_sf %>% select(c(fid, C_Risk,C_Risk_Red_Ratio, Sed_Ret_Ratio, Sed_export, Nature_Access, N_export, N_Ret_Ratio, Pollination))
hotspots_sf <- st_drop_geometry(hotspots_sf)

# check if summary sf worked (has all the values correctly identified)
hp2 <- res$summary_sf
hp2$c_fid.y <- NULL 
hp2$hotspot_services <- NULL
hp2 <- hp2 %>% filter(!is.na(hotspot_count)) # this should be INSIDE of the function, will take care of this later
hp2 <- left_join(hp2, hotspots_sf, by = 'fid')

all <- c("Nature_Access","Pollination","N_Ret_Ratio","Sed_Ret_Ratio","C_Risk_Red_Ratio","Sed_export","N_export","C_Risk")
st_write(hp2, here("output_data", "hotspots_5_final.gpkg"), append=FALSE)
inverse_df <- inverse_df %>% filter(service %in% all)
#rm(res, sf_f)

```

# 2 Produce Scatterplots.

### 2.1.1 Load Data

```{r load_plotting data res}

load(here("output_data", "res_hs_5.RData"))

plt_long <- res$hotspots_df
inverse_df  <- res$non_hotspots_df

all <- c("Nature_Access","Pollination","N_Ret_Ratio","Sed_Ret_Ratio","C_Risk_Red_Ratio","Sed_export","N_export","C_Risk")

inverse_df <- inverse_df %>% filter(service %in% all)
rm(res)
```

## 2.1 Hotspots

```{r scatterplot, fig.height=7, fig.width=12, warning=FALSE}
# Make names shorter
socio_labels <- c(
  "GHS_BUILT_S_E2020_mean" = "Built Area",
  "fields_mehrabi_2017_mean" = "Field Size",
  "hdi_raster_predictions_2020_mean" = "HDI",
  "rast_adm1_gini_disp_2020_mean" = "Income Inequality",
  "rast_gdpTot_1990_2020_30arcsec_2020_sum" = "GDP (Total)",
  "GHS_POP_E2020_GLOBE_sum" = "Population (GHS)",
  "GlobPOP_Count_30arc_2020_sum" = "Population (Global)"
)
files_hot_only <- plot_hotspot_density_bin2d(
  plt_long, inverse_df,
  socio_labels = socio_labels,
  which_layers = "hotspots",
  drop_services = "Rt_nohab",
  trim_p = c(0.01, 0.99),
  y_trim_p = c(0.01, 0.99),          # optional; helps if y is very skewed
  single_fill_limits = c(0.02, 0.98),
  single_limits_mode = "quantile",
  per_facet_stretch = FALSE,         # try TRUE to maximize local contrast
  run_id = "hot_only_q02_098",
  out_dir = "output_charts",
  filename_suffix = "_bin2d.png"
)

```

## 2.2 Non- Hotpots

```{r plot 2, fig.height=7, fig.width=12, warning=FALSE}

files_bg_only <- plot_hotspot_density_bin2d(
  plt_long, inverse_df,
  socio_labels = socio_labels,
  which_layers = "nonhotspots",
  drop_services = "Rt_nohab",
  trim_p = c(0.01, 0.99),
  y_trim_p = c(0.01, 0.99),
  single_fill_limits = c(0.02, 0.98),
  single_limits_mode = "quantile",
  run_id = "nonhot_only_q02_098",
  out_dir = "output_charts",
  filename_suffix = "_bin2d.png"
)

```

## 2.3 Hotspot-Not Hotspot Overlay.

```{r runh plot, fig.height=7, fig.width=12, warning=FALSE}

# 0) make sure the function is sourced
# source("plot_hotspot_density_bin2d.R")  # uncomment if you saved it to a file

# 1) labels (adjust if needed)
socio_labels <- c(
  "GHS_BUILT_S_E2020_mean"           = "Built Area",
  "fields_mehrabi_2017_mean"         = "Field Size",
  "hdi_raster_predictions_2020_mean" = "HDI",
  "rast_adm1_gini_disp_2020_mean"    = "Income Inequality",
  "rast_gdpTot_1990_2020_30arcsec_2020_sum" = "GDP (Total)",
  "GHS_POP_E2020_GLOBE_sum"          = "Population (GHS)",
  "GlobPOP_Count_30arc_2020_sum"     = "Population (Global)"
)

# 2) baseline run — global/service stretch, 2–98% quantiles
files_baseline <- plot_hotspot_density_bin2d(
  plt_long         = plt_long,         # hotspots
  inverse_df       = inverse_df,       # non-hotspots (complement)
  socio_labels     = socio_labels,
  drop_services    = "Rt_nohab",
  trim_p           = c(0.01, 0.99),    # x-trim for pct_chg per service
  bg_bins          = 80,
  hs_bins          = 50,
  bg_alpha         = 0.85,
  hs_alpha         = 0.90,
  bg_trans         = "sqrt",
  hs_trans         = "sqrt",
  bg_fill_limits   = c(0.05, 0.95),    # stretch non-hotspot density by quantiles
  hs_fill_limits   = c(0.05, 0.95),    # stretch hotspot density by quantiles
  limits_mode      = "quantile",
  per_facet_stretch = FALSE,           # service-wide (global) stretch
  out_dir          = "output_charts",
  filename_suffix  = "_two_scales_bin2d.png",
  run_id           = "q05_098_service",# human-readable tag; avoids digest dependency
  overwrite        = FALSE,
  width            = 10,
  height           = 6,
  dpi              = 300,
  use_ragg         = TRUE,             # reliable PNG device
  hide_inline      = TRUE,             # avoid RStudio inline device
  print_interactive = TRUE
)
gc()



```

# 3. Run Tests

```{r ks test}

load(here("output_data", "res_hs_5.RData"))

plt_long <- res$hotspots_df
inverse_df  <- res$non_hotspots_df


# check if summary sf worked (has all the values correctly identified)
hp2 <- res$summary_sf
hp2$c_fid.y <- NULL 
hp2$hotspot_services <- NULL
hp2 <- hp2 %>% filter(!is.na(hotspot_count)) # this should be INSIDE of the function, will take care of this later
hp2 <- left_join(hp2, hotspots_sf, by = 'fid')

all <- c("Nature_Access","Pollination","N_Ret_Ratio","Sed_Ret_Ratio","C_Risk_Red_Ratio","Sed_export","N_export","C_Risk")
st_write(hp2, here("output_data", "hotspots_5_final.gpkg"), append=FALSE)
inverse_df <- inverse_df %>% filter(service %in% all)
rm(res, sf_f)


# Run KS tests: hotspots vs non-hotspots per service for selected variables
run_ks_hot_vs_non <- function(
  plt_long, inverse_df,
  vars = c("rast_gdpTot_1990_2020_30arcsec_2020_sum",
           "GHS_POP_E2020_GLOBE_sum", "GlobPOP_Count_30arc_2020_sum"),
  services = NULL,
  adjust_method = "BH",
  permute_n = 0,              # >0 to compute permutation p-values
  seed = 42,
  out_csv = "output_charts/ks_results_hot_vs_non.csv"
) {
  set.seed(seed)

  # tag groups and combine
  df <- bind_rows(
    plt_long   %>% mutate(group = "hotspot"),
    inverse_df %>% mutate(group = "nonhotspot")
  )

  # subset services if provided
  if (!is.null(services)) {
    df <- df %>% filter(service %in% services)
  }

  # helper: one KS (and optional permutation) for one service/variable
  ks_one <- function(d, v, permute_n = 0) {
    x <- d %>% filter(group == "hotspot")    %>% pull(.data[[v]])
    y <- d %>% filter(group == "nonhotspot") %>% pull(.data[[v]])
    x <- as.numeric(x); y <- as.numeric(y)
    x <- x[is.finite(x)]; y <- y[is.finite(y)]
    n_hot <- length(x); n_non <- length(y)

    if (n_hot < 2 || n_non < 2) {
      return(tibble(D = NA_real_, p_value = NA_real_, p_perm = NA_real_,
                    n_hot = n_hot, n_non = n_non))
    }

    # KS (asymptotic p; ties -> approximate)
    kt <- suppressWarnings(stats::ks.test(x, y, alternative = "two.sided", exact = FALSE))
    D_obs <- as.numeric(kt$statistic)
    p_asym <- kt$p.value

    # Optional permutation p-value (label shuffle within service)
    p_perm <- NA_real_
    if (permute_n > 0) {
      z <- c(x, y)
      g <- c(rep(1L, n_hot), rep(0L, n_non))
      D_perm <- numeric(permute_n)
      for (i in seq_len(permute_n)) {
        g_shuf <- sample(g)
        D_perm[i] <- suppressWarnings(as.numeric(
          stats::ks.test(z[g_shuf == 1L], z[g_shuf == 0L], exact = FALSE)$statistic
        ))
      }
      p_perm <- mean(D_perm >= D_obs)
    }

    tibble(D = D_obs, p_value = p_asym, p_perm = p_perm,
           n_hot = n_hot, n_non = n_non)
  }

  # run per var × service
  results <- map_dfr(vars, function(v) {
    df %>%
      select(service, group, val = .data[[v]]) %>%
      filter(!is.na(val)) %>%
      group_by(service) %>%
      group_modify(~ ks_one(.x %>% mutate(!!v := val, .keep="unused"), v, permute_n)) %>%
      ungroup() %>%
      mutate(var = v, .before = 1)
  }) %>%
    group_by(var) %>%
    mutate(p_adj = p.adjust(p_value, method = adjust_method)) %>%
    ungroup() %>%
    arrange(var, service)

  # write results
  dir.create(dirname(out_csv), recursive = TRUE, showWarnings = FALSE)
  readr::write_csv(results, out_csv)
  results
}

```

```{r run KS}
vars_to_test <- c("rast_gdpTot_1990_2020_30arcsec_2020_sum",
                  "GHS_POP_E2020_GLOBE_sum","GlobPOP_Count_30arc_2020_sum", "GHS_BUILT_S_E2020_mean", "fields_mehrabi_2017_mean","hdi_raster_predictions_2020_mean", "rast_adm1_gini_disp_2020_mean" )
ks_res <- run_ks_hot_vs_non(
  plt_long, inverse_df,
  vars         = vars_to_test,
  adjust_method = "BH",
  permute_n     = 0,   # set to, say, 2000 for permutation p-values (slower)
  out_csv       = here("output_data", "ks_results_hot_vs_non.csv")
)

ks_res
```


```{r ECD overlay}

plot_ecdf_hot_vs_non <- function(plt_long, inverse_df, service_id, var) {
  dd <- bind_rows(
    plt_long   %>% mutate(group = "hotspot"),
    inverse_df %>% mutate(group = "nonhotspot")
  ) %>%
    filter(service == service_id) %>%
    transmute(group, val = as.numeric(.data[[var]])) %>%
    filter(is.finite(val))

  ggplot(dd, aes(val, color = group)) +
    stat_ecdf(size = 0.8) +
    labs(title = paste("ECDF:", service_id, "-", var),
         x = var, y = "F(value)", color = NULL) +
    theme_minimal()
}
```



```{r aubmrnt + plots}


# ----(1) Augment KS with direction: median difference + AUC (MW-based) ----
augment_ks_with_direction <- function(plt_long, inverse_df, ks_res, vars) {
  # bind groups
  base <- bind_rows(
    plt_long   %>% mutate(group = "hotspot"),
    inverse_df %>% mutate(group = "nonhotspot")
  ) %>%
    select(service, group, all_of(vars))

  # long for convenience
  long <- base %>%
    pivot_longer(cols = all_of(vars), names_to = "var", values_to = "val") %>%
    filter(is.finite(val))

  # helper: AUC = P(hotspot > nonhotspot)
  auc_one <- function(x, y) {
    # Wilcoxon W = sum of ranks of x minus n_x*(n_x+1)/2
    nx <- length(x); ny <- length(y)
    if (nx == 0 || ny == 0) return(NA_real_)
    r <- rank(c(x, y), ties.method = "average")
    W <- sum(r[seq_len(nx)]) - nx*(nx+1)/2
    AUC <- W / (nx * ny)
    as.numeric(AUC)
  }

  dir_summ <- long %>%
    group_by(service, var) %>%
    summarise(
      med_hot  = median(val[group == "hotspot"], na.rm = TRUE),
      med_non  = median(val[group == "nonhotspot"], na.rm = TRUE),
      delta_med = med_hot - med_non,
      auc = auc_one(val[group == "hotspot"], val[group == "nonhotspot"]),
      n_hot = sum(group == "hotspot"),
      n_non = sum(group == "nonhotspot"),
      .groups = "drop"
    )

  ks_res %>%
    left_join(dir_summ, by = c("service","var"))
}

# ----(2) Heatmap of D with direction arrows (↑ hotspot higher; ↓ lower) ----
plot_ks_heatmap <- function(ks_aug, title = "KS effect size (D) by service × variable") {
  # order services by mean D across variables for nicer display
  ord <- ks_aug %>%
    group_by(service) %>%
    summarise(D_mean = mean(D, na.rm = TRUE), .groups = "drop") %>%
    arrange(desc(D_mean)) %>% pull(service)

  ks_aug %>%
    mutate(service = factor(service, levels = ord),
           var = factor(var)) %>%
    ggplot(aes(service, var, fill = D)) +
    geom_tile(color = "white", linewidth = 0.15) +
    # arrow annotation (direction by median difference)
    geom_text(aes(label = ifelse(is.na(delta_med), "",
                                 ifelse(delta_med > 0, "↑", "↓"))),
              size = 3, color = "white") +
    scale_fill_viridis_c(option = "C", limits = c(0, NA), oob = squish, name = "KS D") +
    coord_fixed() +
    labs(title = title, x = "Service", y = "Variable",
         subtitle = "Arrow shows direction of median difference (hotspot vs non-hotspot)") +
    theme_minimal(base_size = 11) +
    theme(
      axis.text.x = element_text(angle = 45, hjust = 1),
      panel.grid = element_blank()
    )
}

# ----(3) Bar charts: top-K services by D per variable ---------------------
plot_ks_bars <- function(ks_aug, var_id, top_k = 10) {
  d <- ks_aug %>%
    filter(var == var_id) %>%
    arrange(desc(D)) %>%
    mutate(service = fct_reorder(service, D))
  d_top <- head(d, top_k)
  ggplot(d_top, aes(service, D, fill = D)) +
    geom_col() +
    coord_flip() +
    scale_fill_viridis_c(option = "C", guide = "none") +
    labs(title = paste0("Top ", top_k, " services by KS D — ", var_id),
         x = NULL, y = "KS D") +
    theme_minimal(base_size = 11)
}

# ----(4) ECDF overlays for top-K services per variable --------------------
plot_ecdf_grid <- function(plt_long, inverse_df, var_id, top_k = 4, transform = c("identity","log1p")[2]) {
  transform <- match.arg(transform)
  base <- bind_rows(
    plt_long   %>% mutate(group = "hotspot"),
    inverse_df %>% mutate(group = "nonhotspot")
  ) %>% select(service, group, val = all_of(var_id)) %>% filter(is.finite(val))

  # compute D to find top services (re-using ks logic quickly)
  find_D <- function(d) {
    x <- d$val[d$group=="hotspot"]; y <- d$val[d$group=="nonhotspot"]
    if (length(x) < 2 || length(y) < 2) return(NA_real_)
    suppressWarnings(as.numeric(stats::ks.test(x, y, exact = FALSE)$statistic))
  }
  top_services <- base %>% group_by(service) %>%
    summarise(D = find_D(cur_data()), .groups = "drop") %>%
    arrange(desc(D)) %>% slice_head(n = top_k) %>% pull(service)

  dd <- base %>% filter(service %in% top_services)

  # transform just for plotting
  if (transform == "log1p") dd <- dd %>% mutate(val = log1p(val))

  ggplot(dd, aes(val, color = group)) +
    stat_ecdf(size = 0.9) +
    facet_wrap(~ service, scales = "free_x") +
    labs(title = paste("ECDF overlays —", var_id, if (transform=="log1p") "(log1p scale)" else ""),
         x = var_id, y = "F(value)", color = NULL) +
    scale_color_manual(values = c("nonhotspot"="#2D708E", "hotspot"="#D43D51")) +
    theme_minimal(base_size = 11) +
    theme(legend.position = "top")
}

# ----(5) Mountain plot (CDF difference) for one service × variable --------
plot_ks_mountain <- function(plt_long, inverse_df, service_id, var_id, transform = c("identity","log1p")[2], n_grid = 512) {
  transform <- match.arg(transform)
  dd <- bind_rows(
    plt_long   %>% mutate(group = "hotspot"),
    inverse_df %>% mutate(group = "nonhotspot")
  ) %>% filter(service == service_id) %>%
    transmute(group, x = as.numeric(.data[[var_id]])) %>%
    filter(is.finite(x))
  if (transform == "log1p") dd <- dd %>% mutate(x = log1p(x))

  if (nrow(dd) < 4) stop("Too few points for mountain plot")

  rng <- range(dd$x)
  grid <- seq(rng[1], rng[2], length.out = n_grid)

  ecdf_h <- ecdf(dd$x[dd$group=="hotspot"])
  ecdf_n <- ecdf(dd$x[dd$group=="nonhotspot"])
  delta  <- ecdf_h(grid) - ecdf_n(grid)
  D      <- max(abs(delta), na.rm = TRUE)

  tib <- tibble(x = grid, delta = delta)

  ggplot(tib, aes(x, delta)) +
    geom_hline(yintercept = 0, color = "grey60") +
    geom_line(size = 0.9) +
    labs(title = paste("Mountain plot:", service_id, "—", var_id),
         subtitle = paste0("Max |Δ| = D = ", signif(D, 3),
                           "   (positive = hotspots higher CDF)"),
         x = if (transform=="log1p") paste0(var_id, " (log1p)") else var_id,
         y = expression(F[hot](x) - F[non](x))) +
    theme_minimal(base_size = 11)
}
```

```{r plot ks}

# 1) Augment KS table with direction summaries
vars_to_test <-  c("rast_gdpTot_1990_2020_30arcsec_2020_sum",
                  "GHS_POP_E2020_GLOBE_sum",
                  "GlobPOP_Count_30arc_2020_sum", 
                  "GHS_BUILT_S_E2020_mean",
                  "fields_mehrabi_2017_mean",
                  "hdi_raster_predictions_2020_mean",
                  "rast_adm1_gini_disp_2020_mean" )

ks_aug <- augment_ks_with_direction(plt_long, inverse_df, ks_res, vars_to_test)

# 2) Heatmap of D with direction arrows
p_heat <- plot_ks_heatmap(ks_aug)
ggsave(here("output_charts", "ks_heatmap.png"), p_heat, width = 10, height = 6, dpi = 300, bg = "white")

# 3) Bars by variable
dir.create("output_charts/ks", showWarnings = FALSE, recursive = TRUE)#
for (v in vars_to_test) {
  p_bar <- plot_ks_bars(ks_aug, v, top_k = 12)
  ggsave(file.path(here("output_charts"), paste0("ks_bars_", v, ".png")),
         p_bar, width = 8, height = 6, dpi = 300, bg = "white")
}

# 4) ECDF overlays for top services (log1p scale works well for GDP/pop)
p_ecdf_gdp <- plot_ecdf_grid(plt_long, inverse_df,
                             "rast_gdpTot_1990_2020_30arcsec_2020_sum",
                             top_k = 6, transform = "log1p")
ggsave(here("output_charts","ecdf_gdp.png"), p_ecdf_gdp, width = 10, height = 7, dpi = 300, bg = "white")

p_ecdf_pop <- plot_ecdf_grid(plt_long, inverse_df,
                             "GHS_POP_E2020_GLOBE_sum",
                             top_k = 6, transform = "log1p")
ggsave("output_charts/ks/ecdf_pop.png", p_ecdf_pop, width = 10, height = 7, dpi = 300, bg = "white")

# 5) Mountain plot for a specific service × variable (pick a “big D”)
p_mtn <- plot_ks_mountain(plt_long, inverse_df,
                          service_id = "Pollination",
                          var_id = "rast_gdpTot_1990_2020_30arcsec_2020_sum",
                          transform = "log1p")
ggsave(here("output_charts", /ks/mountain_pollination_gdp.png", p_mtn, width = 8, height = 5, dpi = 300, bg = "white")
```
