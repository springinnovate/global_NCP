---
title: "Hotspot Extraction"
format: html
editor: visual
---

```{r setup, message=FALSE, warning=FALSE}
library(terra)
library(sf)
library(dplyr)
library(ggplot2)
library(tidyr)
library(purrr)
library(diffeR)
library(here)
library(stringr)
library(tidytext)
library(rlang)
library(tidyr)
library(forcats)
library(scales)
library(RColorBrewer)
library(htmltools)
library(leaflet)
library(devtools)
library(reticulate)
library(exactextractr)
library(httpgd)
library(ggnewscale)   # allows multiple fill scales
library(viridisLite)
library(ragg)
load_all()

#source the helper functions
# set venv focr Python
use_virtualenv("/home/jeronimo/venvs/coastal_snap_env", required = TRUE)
#inpath <- '/Users/rodriguez/Library/CloudStorage/OneDrive-WorldWildlifeFund,Inc/global_NCP/output_data'

```

####################### START HERE

# 1 Hotspot Extraction

## 1.1 Prepare Date for Analysis

The spatial objects with the additional attributes are loaded and reformatted for analysis and chart preparation, that requires to **pivot** the input vector files into the long format, with one  row per service/cell combination.

```{r pivot}
#| eval: true
#| include: true
 inpath <- here("output_data")
 inpath <- '/home/jeronimo/OneDrive/PROJECTS/Global_NCP/Final_outputs'
#  get pct as standalone data to add to the table
# Most recent version of synthesis data:
#sf_f <- st_read(paste0(inpath, '/', '10k_grid_ES_change_benef_f.gpkg'))
lyr_sf <- st_layers("/home/jeronimo/OneDrive/PROJECTS/Global_NCP/Final_outputs/10k_change_calc.gpkg")
sf_f <- st_read("/home/jeronimo/OneDrive/PROJECTS/Global_NCP/Final_outputs/10k_change_calc.gpkg") 

sf_f <- sf_f %>% relocate(starts_with("Rt_"), .before = GHS_BUILT_S_E2020_mean)
#change na,mes here (homogenize) 
#this as cbackup, remove as soon as possible.
#sf_f <- sf_f %>% mutate(fid=fid_2)
# add fid # THIS DOOES NOT WORK LIKE THIS!!!!!! DO NOT USE!!!
sf_f$fid <- seq_len(nrow(sf_f)) 
plt <- st_drop_geometry(sf_f)

# get the benef vars (all that are not "chg")
socio_vars <- names(plt)[
  names(plt) != c("fid", "c_fid") & 
  !grepl("chg$", names(plt))
]

# Pivot all columns that contain pct_ch, keeping other relevant vars

plt_long <- plt %>%
  pivot_longer(
    cols = matches("pct_chg"),
    names_to = "service",
    values_to = "pct_chg"
  ) %>%
  select(fid, c_fid, service, pct_chg, all_of(socio_vars)) %>% 
  mutate(service = str_replace(service, "_pct_chg.*", "")) %>% 
  mutate(service = str_replace(service, "_mean.*", "")) %>% 
  filter(!is.na(pct_chg)) %>% filter(!is.na(c_fid)) %>% filter(pct_chg != Inf)  # remove infinite values and those for which Country Id is NA. I need to make sure this is correct. There are sopme locations that have no country values (because it is outside. I am dropping that, but need tto reconsider this)
  
# rename some variables (just for aesthetics)

  plt_long <- plt_long %>% mutate(service = case_when(
   service == "sed_export" ~ "Sed_export",
   service == "n_export" ~ "N_export",
   service == "n_retention" ~ "N_retention",
   service == "nature_access" ~ "Nature_Access",
   service == "pollination" ~ "Pollination",
   service == "usle" ~ "USLE",
   service == "n_ret_ratio" ~ "N_Ret_Ratio",
   service == "sed_ret_ratio" ~ "Sed_Ret_Ratio",
   service == "Rt_ratio" ~ "C_Risk_Red_Ratio",
   service == "Rt" ~ "C_Risk",
   service == "Rt_service" ~ "C_Prot_service",
   TRUE ~ service
   ))
  
  

# Set service levels one single time and for all. Don't drop some variables here, filter afterwards, it can be difficult/annoying to recover!!!
service_levels <- c("Nature_Access","N_export","N_retention", "N_Ret_Ratio", "Sed_export", "USLE", "Sed_Ret_Ratio", "Rt_nohab","C_Risk","C_Prot_service", "C_Risk_Red_Ratio", "Pollination") 

```



```{r hotpots 2}

# Adjust This. Set the variables outside as they shou;d:
## Define the intended direction of change (service loss/increased damage)
loss <- c("Nature_Access","Pollination","N_Ret_Ratio","Sed_Ret_Ratio","C_Risk_Red_Ratio")
gain <- c("Sed_export","N_export","C_Risk")

 combos = list(
    combo_1 = c("Nature_Access","Pollination","N_export","Sed_export","C_Risk"),
    combo_2 = c("Nature_Access","Pollination","N_Ret_Ratio","Sed_Ret_Ratio","C_Risk_Red_Ratio")
  ),
# after running:
hs <- extract_hotspots(
  df = plt_long,
  value_col = "pct_chg",
  pct_cutoff = 0.05,
  threshold_mode = "percent",
  rule_mode = "vectors",
  loss_services = c("Nature_Access","Pollination","N_Ret_Ratio","Sed_Ret_Ratio","C_Risk_Red_Ratio"),
  gain_services = c("Sed_export","N_export","C_Risk"),
  combos = list(
    deg_combo = c("Nature_Access","Pollination","N_export","Sed_export","C_Risk"),
    rec_combo = c("Nature_Access","Pollination","N_Ret_Ratio","Sed_Ret_Ratio","C_Risk_Red_Ratio")
  ),
  id_cols = c("c_fid"),
  sf_obj = sf_f,                                       # your sf with fid
  write_sf_path = "output_data/hotspots3.gpkg",       # or "output_charts/hotspots.shp"
  write_driver  = "GPKG",                              # or "ESRI Shapefile"
  clean_names   = TRUE,
  fid_alias     = "fid_2",                             # duplicate fid only for the file
  drop_fid_on_write = TRUE                             # drop original fid on disk (keep in memory)
)

# hotspots_sf <- st_read('/Users/rodriguez/OneDrive - World Wildlife Fund, Inc/global_NCP/output_data/hotspots_5_final.gpkg')
hp_sf <- hs$hotspots_sf
hp_sf <- hp_sf %>% select(-ends_with("_abs_chg"))
```

# Masking
Whathappens here is  that i mask each one of the outputs, and fix the names to try to get this to make morr sense, be more replicable/consitent and facilitate the plottting (already done), by masking each binary with the value for plotting. Nevertheless, i think there is a smarter way to do this and i should aske for advice.

```{r prelim fixing names}


mask_pct_change_by_hotspot <- function(hp_sf,
                                       services_keep = c("Nature_Access","N_export","N_retention",
                                                         "N_Ret_Ratio","Sed_export","USLE",
                                                         "Sed_Ret_Ratio","Rt_nohab",
                                                         "C_Risk","C_Prot_service",
                                                         "C_Risk_Red_Ratio","Pollination"),
                                       value_suffix_re = "(?:_pct_?chg)$",   # _pct_chg or _pctchg
                                       masked_suffix   = "_masked",
                                       verbose = TRUE) {
  stopifnot(inherits(hp_sf, "sf"))

  nm <- names(hp_sf)

  # find *_pct_chg / *_pctchg (case-insensitive)
  val_cols <- nm[str_detect(nm, regex(value_suffix_re, ignore_case = TRUE))]
  if (length(val_cols) == 0L) {
    if (verbose) message("No percent-change columns found. Nothing to mask.")
    return(hp_sf)
  }

  # stems (drop suffix; case-insensitive)
  stems <- tolower(str_remove(val_cols, regex(value_suffix_re, ignore_case = TRUE)))
  stems_nomean <- str_remove(stems, "_mean$")

  # map stems -> hotspot binary service names
  service_map <- c(
    "nature_access"   = "Nature_Access",
    "n_export"        = "N_export",
    "n_retention"     = "N_retention",
    "n_ret_ratio"     = "N_Ret_Ratio",
    "sed_export"      = "Sed_export",
    "usle"            = "USLE",
    "sed_ret_ratio"   = "Sed_Ret_Ratio",
    "pollination"     = "Pollination",
    "rt_nohab_mean"   = "Rt_nohab",
    "rt_nohab"        = "Rt_nohab",
    "rt_ratio_mean"   = "C_Risk_Red_Ratio",
    "rt_ratio"        = "C_Risk_Red_Ratio",
    "rt_service_mean" = "C_Prot_service",
    "rt_service"      = "C_Prot_service",
    "rt_mean"         = "C_Risk",
    "rt"              = "C_Risk"
  )

  svc_from_stem <- function(st) {
    if (!is.na(service_map[st])) as.character(service_map[st])
    else if (!is.na(service_map[str_remove(st, "_mean$")])) as.character(service_map[str_remove(st, "_mean$")])
    else NA_character_
  }
  services <- vapply(stems, svc_from_stem, FUN.VALUE = character(1))

  map_tbl <- tibble(
    val_col = val_cols,
    stem    = stems,
    service = services,
    bin_col = services  # binary cols named by service
  ) %>%
    filter(!is.na(service)) %>%
    { if (is.null(services_keep)) . else filter(., service %in% services_keep) } %>%
    filter(val_col %in% nm, bin_col %in% nm)

  if (nrow(map_tbl) == 0L) {
    if (verbose) message("No valueâ†”binary pairs found to mask.")
    return(hp_sf)
  }

  for (i in seq_len(nrow(map_tbl))) {
    v   <- map_tbl$val_col[i]
    b   <- map_tbl$bin_col[i]
    out <- paste0(v, masked_suffix)

    hp_sf[[out]] <- ifelse(hp_sf[[b]] == 1L, as.numeric(hp_sf[[v]]), NA_real_)
    hp_sf <- hp_sf %>% relocate(all_of(out), .after = all_of(v))
  }

  if (verbose) message("Masked ", nrow(map_tbl), " layer(s): ", paste0(map_tbl$service, collapse = ", "))
  hp_sf
}


hp_sf <- mask_pct_change_by_hotspot(hp_sf)

# sanity check: see the new *_masked columns
names(hp_sf)[str_detect(names(hp_sf), "_pct_?chg_masked$")]
st_write(hp_sf, paste0(inpath, '/', 'hotspots_5_final_mskd.gpkg'))
         
```


## 1.2 Get Hotspots

```{r run get hotsposts function}


res <- extract_hotspots(
  df = plt_long,
  value_col = "pct_chg",
  pct_cutoff = 0.05,
  threshold_mode = "percent",
  rule_mode = "vectors",
  loss_services = loss,
  gain_services = gain,
  combos = list(
    combo_1 = c("Nature_Access","Pollination","N_export","Sed_export","C_Risk"),
    combo_2 = c("Nature_Access","Pollination","N_Ret_Ratio","Sed_Ret_Ratio","C_Risk_Red_Ratio")
  ),
  #side = "both",
  id_cols = "c_fid", # rename this to "other cols" needs to accept a vector. 
  sf_obj = sf_f
)

hotspots_sf <- res$hotspots_sf#
hotspots_sf <- hotspots_sf %>% mutate(fid_2=fid)
hotspots_sf$fid <- NULL


```



# assuming `nams1` and `nams2` are defined and ordered
for (i in seq_along(nams1)) {
  val_col <- nams1[i]
  bin_col <- nams2[i]
  masked_col <- paste0(val_col, "_masked")

  hp_sf[[masked_col]] <- ifelse(hp_sf[[bin_col]] == 1, hp[[val_col]], NA)
}

# st_write(hp, '/Users/rodriguez/OneDrive - World Wildlife Fund, Inc/global_NCP/output_data/hotspots_5_final_mskd.gpkg')

```




```{r kolmogorv}
# # reuse the KS helper I gave you earlier
# vars_to_test <- c("rast_gdpTot_1990_2020_30arcsec_2020_sum",
#                   "GHS_POP_E2020_GLOBE_sum",
#                   "GlobPOP_Count_30arc_2020_sum")
# 
# ks_res <- run_ks_hot_vs_non(
#   plt_long   = res$hotspots_df,
#   inverse_df = res$non_hotspots_df,
#   vars = vars_to_test,
#   adjust_method = "BH",
#   permute_n = 0,
#   out_csv = "output_charts/ks_results_hot_vs_non.csv"
# )
# 
# ```
# 
# 
# 
# Get values to plot
# 
# ```{r get names}
# 
# 2 Produce Scatterplots.


### 2.1.1 Load Data

```{r load_plotting data res}

load(here("output_data", "res_hs_5.RData"))

plt_long <- res$hotspots_df
inverse_df  <- res$non_hotspots_df

all <- c("Nature_Access","Pollination","N_Ret_Ratio","Sed_Ret_Ratio","C_Risk_Red_Ratio","Sed_export","N_export","C_Risk")

inverse_df <- inverse_df %>% filter(service %in% all)
rm(res)
``` 
## 2.1 Hotspots

```{r scatterplot, fig.height=7, fig.width=12, warning=FALSE}
# Make names shorter
socio_labels <- c(
  "GHS_BUILT_S_E2020_mean" = "Built Area",
  "fields_mehrabi_2017_mean" = "Field Size",
  "hdi_raster_predictions_2020_mean" = "HDI",
  "rast_adm1_gini_disp_2020_mean" = "Income Inequality",
  "rast_gdpTot_1990_2020_30arcsec_2020_sum" = "GDP (Total)",
  "GHS_POP_E2020_GLOBE_sum" = "Population (GHS)",
  "GlobPOP_Count_30arc_2020_sum" = "Population (Global)"
)
files_hot_only <- plot_hotspot_density_bin2d(
  plt_long, inverse_df,
  socio_labels = socio_labels,
  which_layers = "hotspots",
  drop_services = "Rt_nohab",
  trim_p = c(0.01, 0.99),
  y_trim_p = c(0.01, 0.99),          # optional; helps if y is very skewed
  single_fill_limits = c(0.02, 0.98),
  single_limits_mode = "quantile",
  per_facet_stretch = FALSE,         # try TRUE to maximize local contrast
  run_id = "hot_only_q02_098",
  out_dir = "output_charts",
  filename_suffix = "_bin2d.png"
)
```

## 2.2 Non- Hotpots

```{r plot 2, fig.height=7, fig.width=12, warning=FALSE}

files_bg_only <- plot_hotspot_density_bin2d(
  plt_long, inverse_df,
  socio_labels = socio_labels,
  which_layers = "nonhotspots",
  drop_services = "Rt_nohab",
  trim_p = c(0.01, 0.99),
  y_trim_p = c(0.01, 0.99),
  single_fill_limits = c(0.02, 0.98),
  single_limits_mode = "quantile",
  run_id = "nonhot_only_q02_098",
  out_dir = "output_charts",
  filename_suffix = "_bin2d.png"
)

```

## 2.3 Hotspot-Not Hotspot Overlay.

```{r runh plot, fig.height=7, fig.width=12, warning=FALSE}

# 0) make sure the function is sourced
# source("plot_hotspot_density_bin2d.R")  # uncomment if you saved it to a file

# 1) labels (adjust if needed)
socio_labels <- c(
  "GHS_BUILT_S_E2020_mean"           = "Built Area",
  "fields_mehrabi_2017_mean"         = "Field Size",
  "hdi_raster_predictions_2020_mean" = "HDI",
  "rast_adm1_gini_disp_2020_mean"    = "Income Inequality",
  "rast_gdpTot_1990_2020_30arcsec_2020_sum" = "GDP (Total)",
  "GHS_POP_E2020_GLOBE_sum"          = "Population (GHS)",
  "GlobPOP_Count_30arc_2020_sum"     = "Population (Global)"
)

# 2) baseline run â€” global/service stretch, 2â€“98% quantiles
files_baseline <- plot_hotspot_density_bin2d(
  plt_long         = plt_long,         # hotspots
  inverse_df       = inverse_df,       # non-hotspots (complement)
  socio_labels     = socio_labels,
  drop_services    = "Rt_nohab",
  trim_p           = c(0.01, 0.99),    # x-trim for pct_chg per service
  bg_bins          = 80,
  hs_bins          = 50,
  bg_alpha         = 0.85,
  hs_alpha         = 0.90,
  bg_trans         = "sqrt",
  hs_trans         = "sqrt",
  bg_fill_limits   = c(0.05, 0.95),    # stretch non-hotspot density by quantiles
  hs_fill_limits   = c(0.05, 0.95),    # stretch hotspot density by quantiles
  limits_mode      = "quantile",
  per_facet_stretch = FALSE,           # service-wide (global) stretch
  out_dir          = "output_charts",
  filename_suffix  = "_two_scales_bin2d.png",
  run_id           = "q05_098_service",# human-readable tag; avoids digest dependency
  overwrite        = FALSE,
  width            = 10,
  height           = 6,
  dpi              = 300,
  use_ragg         = TRUE,             # reliable PNG device
  hide_inline      = TRUE,             # avoid RStudio inline device
  print_interactive = TRUE
)
gc()
```
